// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: status.tl.proto

package status

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	mtproto "github.com/teamgram/proto/mtproto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TLConstructor int32

const (
	CRC32_UNKNOWN                           TLConstructor = 0
	CRC32_sessionEntry                      TLConstructor = 392473649
	CRC32_userSessionEntryList              TLConstructor = -269700200
	CRC32_status_setSessionOnline           TLConstructor = 1381075919
	CRC32_status_setSessionOffline          TLConstructor = 631663196
	CRC32_status_getUserOnlineSessions      TLConstructor = -406788659
	CRC32_status_getUsersOnlineSessionsList TLConstructor = -2009385532
)

var TLConstructor_name = map[int32]string{
	0:           "CRC32_UNKNOWN",
	392473649:   "CRC32_sessionEntry",
	-269700200:  "CRC32_userSessionEntryList",
	1381075919:  "CRC32_status_setSessionOnline",
	631663196:   "CRC32_status_setSessionOffline",
	-406788659:  "CRC32_status_getUserOnlineSessions",
	-2009385532: "CRC32_status_getUsersOnlineSessionsList",
}

var TLConstructor_value = map[string]int32{
	"CRC32_UNKNOWN":                           0,
	"CRC32_sessionEntry":                      392473649,
	"CRC32_userSessionEntryList":              -269700200,
	"CRC32_status_setSessionOnline":           1381075919,
	"CRC32_status_setSessionOffline":          631663196,
	"CRC32_status_getUserOnlineSessions":      -406788659,
	"CRC32_status_getUsersOnlineSessionsList": -2009385532,
}

func (x TLConstructor) String() string {
	return proto.EnumName(TLConstructor_name, int32(x))
}

func (TLConstructor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac2279bebff9f187, []int{0}
}

// SessionEntry <--
//  + TL_sessionEntry
//
type SessionEntry struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=status.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Gateway              string        `protobuf:"bytes,5,opt,name=gateway,proto3" json:"gateway,omitempty"`
	Expired              int64         `protobuf:"varint,6,opt,name=expired,proto3" json:"expired,omitempty"`
	Layer                int32         `protobuf:"varint,7,opt,name=layer,proto3" json:"layer,omitempty"`
	PermAuthKeyId        int64         `protobuf:"varint,8,opt,name=perm_auth_key_id,json=permAuthKeyId,proto3" json:"perm_auth_key_id,omitempty"`
	Client               string        `protobuf:"bytes,9,opt,name=client,proto3" json:"client,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SessionEntry) Reset()         { *m = SessionEntry{} }
func (m *SessionEntry) String() string { return proto.CompactTextString(m) }
func (*SessionEntry) ProtoMessage()    {}
func (*SessionEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac2279bebff9f187, []int{0}
}
func (m *SessionEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionEntry.Merge(m, src)
}
func (m *SessionEntry) XXX_Size() int {
	return m.Size()
}
func (m *SessionEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SessionEntry proto.InternalMessageInfo

func (m *SessionEntry) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *SessionEntry) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *SessionEntry) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionEntry) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *SessionEntry) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *SessionEntry) GetExpired() int64 {
	if m != nil {
		return m.Expired
	}
	return 0
}

func (m *SessionEntry) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *SessionEntry) GetPermAuthKeyId() int64 {
	if m != nil {
		return m.PermAuthKeyId
	}
	return 0
}

func (m *SessionEntry) GetClient() string {
	if m != nil {
		return m.Client
	}
	return ""
}

type TLSessionEntry struct {
	Data2                *SessionEntry `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionEntry) Reset()         { *m = TLSessionEntry{} }
func (m *TLSessionEntry) String() string { return proto.CompactTextString(m) }
func (*TLSessionEntry) ProtoMessage()    {}
func (*TLSessionEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac2279bebff9f187, []int{1}
}
func (m *TLSessionEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLSessionEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionEntry.Merge(m, src)
}
func (m *TLSessionEntry) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionEntry.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionEntry proto.InternalMessageInfo

func (m *TLSessionEntry) GetData2() *SessionEntry {
	if m != nil {
		return m.Data2
	}
	return nil
}

// UserSessionEntryList <--
//  + TL_userSessionEntryList
//
type UserSessionEntryList struct {
	PredicateName        string          `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor   `protobuf:"varint,2,opt,name=constructor,proto3,enum=status.TLConstructor" json:"constructor,omitempty"`
	UserId               int64           `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	UserSessions         []*SessionEntry `protobuf:"bytes,4,rep,name=user_sessions,json=userSessions,proto3" json:"user_sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UserSessionEntryList) Reset()         { *m = UserSessionEntryList{} }
func (m *UserSessionEntryList) String() string { return proto.CompactTextString(m) }
func (*UserSessionEntryList) ProtoMessage()    {}
func (*UserSessionEntryList) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac2279bebff9f187, []int{2}
}
func (m *UserSessionEntryList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSessionEntryList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserSessionEntryList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserSessionEntryList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSessionEntryList.Merge(m, src)
}
func (m *UserSessionEntryList) XXX_Size() int {
	return m.Size()
}
func (m *UserSessionEntryList) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSessionEntryList.DiscardUnknown(m)
}

var xxx_messageInfo_UserSessionEntryList proto.InternalMessageInfo

func (m *UserSessionEntryList) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *UserSessionEntryList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *UserSessionEntryList) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserSessionEntryList) GetUserSessions() []*SessionEntry {
	if m != nil {
		return m.UserSessions
	}
	return nil
}

type TLUserSessionEntryList struct {
	Data2                *UserSessionEntryList `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TLUserSessionEntryList) Reset()         { *m = TLUserSessionEntryList{} }
func (m *TLUserSessionEntryList) String() string { return proto.CompactTextString(m) }
func (*TLUserSessionEntryList) ProtoMessage()    {}
func (*TLUserSessionEntryList) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac2279bebff9f187, []int{3}
}
func (m *TLUserSessionEntryList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLUserSessionEntryList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLUserSessionEntryList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLUserSessionEntryList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLUserSessionEntryList.Merge(m, src)
}
func (m *TLUserSessionEntryList) XXX_Size() int {
	return m.Size()
}
func (m *TLUserSessionEntryList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLUserSessionEntryList.DiscardUnknown(m)
}

var xxx_messageInfo_TLUserSessionEntryList proto.InternalMessageInfo

func (m *TLUserSessionEntryList) GetData2() *UserSessionEntryList {
	if m != nil {
		return m.Data2
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLStatusSetSessionOnline struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=status.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Session              *SessionEntry `protobuf:"bytes,4,opt,name=session,proto3" json:"session,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLStatusSetSessionOnline) Reset()         { *m = TLStatusSetSessionOnline{} }
func (m *TLStatusSetSessionOnline) String() string { return proto.CompactTextString(m) }
func (*TLStatusSetSessionOnline) ProtoMessage()    {}
func (*TLStatusSetSessionOnline) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac2279bebff9f187, []int{4}
}
func (m *TLStatusSetSessionOnline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLStatusSetSessionOnline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLStatusSetSessionOnline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLStatusSetSessionOnline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLStatusSetSessionOnline.Merge(m, src)
}
func (m *TLStatusSetSessionOnline) XXX_Size() int {
	return m.Size()
}
func (m *TLStatusSetSessionOnline) XXX_DiscardUnknown() {
	xxx_messageInfo_TLStatusSetSessionOnline.DiscardUnknown(m)
}

var xxx_messageInfo_TLStatusSetSessionOnline proto.InternalMessageInfo

func (m *TLStatusSetSessionOnline) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLStatusSetSessionOnline) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLStatusSetSessionOnline) GetSession() *SessionEntry {
	if m != nil {
		return m.Session
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLStatusSetSessionOffline struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=status.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLStatusSetSessionOffline) Reset()         { *m = TLStatusSetSessionOffline{} }
func (m *TLStatusSetSessionOffline) String() string { return proto.CompactTextString(m) }
func (*TLStatusSetSessionOffline) ProtoMessage()    {}
func (*TLStatusSetSessionOffline) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac2279bebff9f187, []int{5}
}
func (m *TLStatusSetSessionOffline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLStatusSetSessionOffline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLStatusSetSessionOffline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLStatusSetSessionOffline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLStatusSetSessionOffline.Merge(m, src)
}
func (m *TLStatusSetSessionOffline) XXX_Size() int {
	return m.Size()
}
func (m *TLStatusSetSessionOffline) XXX_DiscardUnknown() {
	xxx_messageInfo_TLStatusSetSessionOffline.DiscardUnknown(m)
}

var xxx_messageInfo_TLStatusSetSessionOffline proto.InternalMessageInfo

func (m *TLStatusSetSessionOffline) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLStatusSetSessionOffline) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLStatusSetSessionOffline) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLStatusGetUserOnlineSessions struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=status.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLStatusGetUserOnlineSessions) Reset()         { *m = TLStatusGetUserOnlineSessions{} }
func (m *TLStatusGetUserOnlineSessions) String() string { return proto.CompactTextString(m) }
func (*TLStatusGetUserOnlineSessions) ProtoMessage()    {}
func (*TLStatusGetUserOnlineSessions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac2279bebff9f187, []int{6}
}
func (m *TLStatusGetUserOnlineSessions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLStatusGetUserOnlineSessions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLStatusGetUserOnlineSessions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLStatusGetUserOnlineSessions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLStatusGetUserOnlineSessions.Merge(m, src)
}
func (m *TLStatusGetUserOnlineSessions) XXX_Size() int {
	return m.Size()
}
func (m *TLStatusGetUserOnlineSessions) XXX_DiscardUnknown() {
	xxx_messageInfo_TLStatusGetUserOnlineSessions.DiscardUnknown(m)
}

var xxx_messageInfo_TLStatusGetUserOnlineSessions proto.InternalMessageInfo

func (m *TLStatusGetUserOnlineSessions) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLStatusGetUserOnlineSessions) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLStatusGetUsersOnlineSessionsList struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=status.TLConstructor" json:"constructor,omitempty"`
	Users                []int64       `protobuf:"varint,3,rep,packed,name=users,proto3" json:"users,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLStatusGetUsersOnlineSessionsList) Reset()         { *m = TLStatusGetUsersOnlineSessionsList{} }
func (m *TLStatusGetUsersOnlineSessionsList) String() string { return proto.CompactTextString(m) }
func (*TLStatusGetUsersOnlineSessionsList) ProtoMessage()    {}
func (*TLStatusGetUsersOnlineSessionsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac2279bebff9f187, []int{7}
}
func (m *TLStatusGetUsersOnlineSessionsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLStatusGetUsersOnlineSessionsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLStatusGetUsersOnlineSessionsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLStatusGetUsersOnlineSessionsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLStatusGetUsersOnlineSessionsList.Merge(m, src)
}
func (m *TLStatusGetUsersOnlineSessionsList) XXX_Size() int {
	return m.Size()
}
func (m *TLStatusGetUsersOnlineSessionsList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLStatusGetUsersOnlineSessionsList.DiscardUnknown(m)
}

var xxx_messageInfo_TLStatusGetUsersOnlineSessionsList proto.InternalMessageInfo

func (m *TLStatusGetUsersOnlineSessionsList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLStatusGetUsersOnlineSessionsList) GetUsers() []int64 {
	if m != nil {
		return m.Users
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// Vector api result type
type Vector_UserSessionEntryList struct {
	Datas                []*UserSessionEntryList `protobuf:"bytes,1,rep,name=datas,proto3" json:"datas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Vector_UserSessionEntryList) Reset()         { *m = Vector_UserSessionEntryList{} }
func (m *Vector_UserSessionEntryList) String() string { return proto.CompactTextString(m) }
func (*Vector_UserSessionEntryList) ProtoMessage()    {}
func (*Vector_UserSessionEntryList) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac2279bebff9f187, []int{8}
}
func (m *Vector_UserSessionEntryList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector_UserSessionEntryList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector_UserSessionEntryList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector_UserSessionEntryList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector_UserSessionEntryList.Merge(m, src)
}
func (m *Vector_UserSessionEntryList) XXX_Size() int {
	return m.Size()
}
func (m *Vector_UserSessionEntryList) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector_UserSessionEntryList.DiscardUnknown(m)
}

var xxx_messageInfo_Vector_UserSessionEntryList proto.InternalMessageInfo

func (m *Vector_UserSessionEntryList) GetDatas() []*UserSessionEntryList {
	if m != nil {
		return m.Datas
	}
	return nil
}

func init() {
	proto.RegisterEnum("status.TLConstructor", TLConstructor_name, TLConstructor_value)
	proto.RegisterType((*SessionEntry)(nil), "status.SessionEntry")
	proto.RegisterType((*TLSessionEntry)(nil), "status.TL_sessionEntry")
	proto.RegisterType((*UserSessionEntryList)(nil), "status.UserSessionEntryList")
	proto.RegisterType((*TLUserSessionEntryList)(nil), "status.TL_userSessionEntryList")
	proto.RegisterType((*TLStatusSetSessionOnline)(nil), "status.TL_status_setSessionOnline")
	proto.RegisterType((*TLStatusSetSessionOffline)(nil), "status.TL_status_setSessionOffline")
	proto.RegisterType((*TLStatusGetUserOnlineSessions)(nil), "status.TL_status_getUserOnlineSessions")
	proto.RegisterType((*TLStatusGetUsersOnlineSessionsList)(nil), "status.TL_status_getUsersOnlineSessionsList")
	proto.RegisterType((*Vector_UserSessionEntryList)(nil), "status.Vector_UserSessionEntryList")
}

func init() { proto.RegisterFile("status.tl.proto", fileDescriptor_ac2279bebff9f187) }

var fileDescriptor_ac2279bebff9f187 = []byte{
	// 818 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x3d, 0x8c, 0xe3, 0x44,
	0x14, 0xce, 0x24, 0x9b, 0x84, 0xbc, 0xbd, 0xdc, 0x99, 0x51, 0x60, 0x8d, 0xef, 0x30, 0xc1, 0x70,
	0x24, 0x3a, 0x71, 0x89, 0x94, 0x43, 0x42, 0x14, 0x57, 0x70, 0x11, 0xc5, 0xe9, 0x42, 0xf6, 0xf0,
	0xed, 0x82, 0x44, 0x63, 0xcd, 0x3a, 0xb3, 0x5e, 0x8b, 0xc4, 0xb6, 0x66, 0xc6, 0xdc, 0xa6, 0xa6,
	0xa1, 0x03, 0x6d, 0x03, 0x34, 0x34, 0x5b, 0x53, 0xb0, 0x2d, 0x12, 0x12, 0x12, 0x42, 0x08, 0x84,
	0xa0, 0xa0, 0xa0, 0xa0, 0x80, 0x6d, 0x28, 0xa0, 0xa0, 0xa4, 0x22, 0xc8, 0x63, 0x7b, 0x9d, 0x28,
	0x4e, 0x16, 0xf1, 0xa3, 0xab, 0x32, 0xef, 0x7d, 0xef, 0xcd, 0xf7, 0xde, 0x37, 0xef, 0x29, 0x86,
	0x4b, 0x5c, 0x10, 0x11, 0xf2, 0x8e, 0x18, 0x77, 0x02, 0xe6, 0x0b, 0x1f, 0x57, 0x62, 0x87, 0x76,
	0xdd, 0x71, 0xc5, 0x41, 0xb8, 0xd7, 0xb1, 0xfd, 0x49, 0xd7, 0xf1, 0x1d, 0xbf, 0x2b, 0xe1, 0xbd,
	0x70, 0x5f, 0x5a, 0xd2, 0x90, 0xa7, 0x38, 0x4d, 0xd3, 0x1d, 0xdf, 0x77, 0xc6, 0x34, 0x8b, 0xba,
	0xcf, 0x48, 0x10, 0x50, 0xc6, 0x13, 0x5c, 0xe3, 0xf6, 0x01, 0x9d, 0x90, 0x88, 0xc7, 0xf6, 0x19,
	0xb5, 0xc4, 0x34, 0xa0, 0x29, 0xf6, 0x58, 0x86, 0x09, 0x46, 0x3c, 0x1e, 0xf8, 0x4c, 0x24, 0x50,
	0x23, 0x83, 0xf8, 0xd4, 0xb3, 0x63, 0xaf, 0x71, 0x52, 0x84, 0x0b, 0xf7, 0x28, 0xe7, 0xae, 0xef,
	0xbd, 0xe4, 0x09, 0x36, 0xc5, 0x57, 0xe1, 0x62, 0xc0, 0xe8, 0xc8, 0xb5, 0x89, 0xa0, 0x96, 0x47,
	0x26, 0x54, 0x45, 0x4d, 0xd4, 0xae, 0x99, 0xf5, 0x33, 0xef, 0x90, 0x4c, 0x28, 0x7e, 0x1e, 0x36,
	0x6d, 0xdf, 0xe3, 0x82, 0x85, 0xb6, 0xf0, 0x99, 0x5a, 0x6c, 0xa2, 0xf6, 0xc5, 0xde, 0x23, 0x9d,
	0x44, 0x82, 0x9d, 0x41, 0x3f, 0x03, 0xcd, 0xf9, 0x48, 0xbc, 0x05, 0xd5, 0x90, 0x53, 0x66, 0xb9,
	0x23, 0xb5, 0xd4, 0x44, 0xed, 0x92, 0x59, 0x89, 0xcc, 0xdb, 0x23, 0xac, 0xc3, 0x26, 0x09, 0xc5,
	0x81, 0xf5, 0x06, 0x9d, 0x46, 0xe0, 0x86, 0x04, 0x6b, 0x91, 0xeb, 0x0e, 0x9d, 0xde, 0x1e, 0x61,
	0x15, 0xaa, 0x0e, 0x11, 0xf4, 0x3e, 0x99, 0xaa, 0x65, 0x59, 0x51, 0x6a, 0x46, 0x08, 0x3d, 0x0c,
	0x5c, 0x46, 0x47, 0x6a, 0x45, 0x66, 0xa5, 0x26, 0x6e, 0x40, 0x79, 0x4c, 0xa6, 0x94, 0xa9, 0xd5,
	0x26, 0x6a, 0x97, 0xcd, 0xd8, 0xc0, 0x2d, 0x50, 0x02, 0xca, 0x26, 0xd6, 0x3c, 0xdd, 0x43, 0x32,
	0xb1, 0x1e, 0xf9, 0x5f, 0x3c, 0xa3, 0x7c, 0x14, 0x2a, 0xf6, 0xd8, 0xa5, 0x9e, 0x50, 0x6b, 0x92,
	0x31, 0xb1, 0x8c, 0x9b, 0x70, 0x69, 0x67, 0x60, 0xf1, 0x79, 0xd9, 0xae, 0x41, 0x79, 0x44, 0x04,
	0xe9, 0x49, 0xb5, 0x36, 0x7b, 0x8d, 0x54, 0x89, 0x79, 0x6d, 0xcd, 0x38, 0xc4, 0xf8, 0x0a, 0x41,
	0x63, 0x97, 0x53, 0x36, 0x8f, 0x0d, 0x5c, 0x2e, 0x1e, 0x9c, 0xf6, 0x2f, 0x40, 0x5d, 0x02, 0x49,
	0x4b, 0x5c, 0xdd, 0x68, 0x96, 0x56, 0x76, 0x71, 0x21, 0xcc, 0x6a, 0xe7, 0xc6, 0xcb, 0xb0, 0xb5,
	0x33, 0xb0, 0xc2, 0xbc, 0x76, 0x7a, 0x8b, 0x9a, 0x5c, 0x49, 0x6f, 0xcb, 0xeb, 0x3d, 0xd5, 0xe6,
	0x43, 0x04, 0x5a, 0xa4, 0xad, 0x8c, 0xb4, 0x38, 0x15, 0x49, 0xe0, 0xb6, 0x37, 0x76, 0xbd, 0xa5,
	0xd6, 0xd1, 0xbf, 0x6f, 0xbd, 0x03, 0xd5, 0xa4, 0x6b, 0x39, 0x72, 0xab, 0x9a, 0x4e, 0x83, 0x8c,
	0x77, 0x10, 0x5c, 0xce, 0x2d, 0x70, 0x7f, 0xff, 0x7f, 0xaa, 0xf0, 0x9c, 0xc5, 0x30, 0x38, 0x3c,
	0x91, 0x15, 0xe4, 0x50, 0x11, 0xc9, 0x1b, 0xcb, 0x95, 0x3e, 0xd2, 0x7f, 0x5f, 0x94, 0x11, 0xc2,
	0xd3, 0x4b, 0xa4, 0x7c, 0x91, 0x55, 0xce, 0xc0, 0x3f, 0x66, 0x6e, 0x40, 0x39, 0xa2, 0xe2, 0x6a,
	0xa9, 0x59, 0x6a, 0x97, 0xcc, 0xd8, 0x30, 0x5e, 0x81, 0xcb, 0xaf, 0xd2, 0x08, 0xb7, 0x76, 0xd7,
	0x4c, 0x1c, 0x57, 0x91, 0x9c, 0xdf, 0xbf, 0x31, 0x71, 0xfc, 0xda, 0x71, 0x11, 0xea, 0x0b, 0x75,
	0xe0, 0x87, 0xa1, 0xde, 0x37, 0xfb, 0x37, 0x7a, 0xd6, 0xee, 0xf0, 0xce, 0x70, 0xfb, 0xb5, 0xa1,
	0x52, 0xc0, 0x1a, 0xe0, 0xd8, 0x35, 0xbf, 0xf4, 0xca, 0xc7, 0x3f, 0x1c, 0x7d, 0x82, 0x70, 0x0b,
	0xb4, 0x18, 0xcb, 0x5b, 0x02, 0xe5, 0xfd, 0x5f, 0x4e, 0x66, 0x7f, 0xce, 0x66, 0xb3, 0x19, 0xc2,
	0x57, 0xe1, 0xf1, 0xe4, 0x92, 0xfc, 0xe9, 0x56, 0xbe, 0x7d, 0xef, 0x8b, 0xa3, 0x32, 0x7e, 0x06,
	0xf4, 0x55, 0x61, 0xf1, 0x8c, 0x29, 0x3f, 0x7e, 0xff, 0xc1, 0x47, 0x45, 0xdc, 0x05, 0x63, 0x21,
	0x2e, 0xf7, 0xe9, 0x95, 0x6f, 0xbe, 0x7e, 0xeb, 0xd3, 0x84, 0xff, 0x39, 0x68, 0xe5, 0x25, 0xe4,
	0x3c, 0x9b, 0xf2, 0xf9, 0xaf, 0xbf, 0x7d, 0xf6, 0x87, 0xcc, 0xd2, 0x36, 0xde, 0x3e, 0xd6, 0x0b,
	0xbd, 0x77, 0x4b, 0x50, 0x33, 0xef, 0xf6, 0xef, 0xc9, 0x4c, 0x3c, 0x84, 0xad, 0x55, 0x1b, 0x6a,
	0x64, 0x6f, 0xbb, 0xaa, 0x4f, 0xad, 0xde, 0x99, 0x08, 0xf9, 0xf7, 0xd3, 0xb9, 0xe5, 0xfb, 0x63,
	0xa3, 0x80, 0xef, 0x82, 0xba, 0x72, 0xa1, 0x9e, 0x5a, 0x7b, 0x61, 0x1c, 0xb4, 0x7c, 0xa3, 0x03,
	0x57, 0xd6, 0x6e, 0x44, 0x6b, 0xf9, 0xd6, 0xdc, 0x40, 0x6d, 0xed, 0x0c, 0x19, 0x05, 0x7c, 0x08,
	0x4f, 0x9e, 0xbf, 0x05, 0xcf, 0xae, 0x64, 0xcb, 0x89, 0xd6, 0xce, 0x3a, 0x5e, 0x33, 0xea, 0x46,
	0xe1, 0xd6, 0xf6, 0xef, 0x3f, 0xeb, 0xe8, 0xcb, 0x53, 0x1d, 0x7d, 0x77, 0xaa, 0xa3, 0x9f, 0x4e,
	0x75, 0xf4, 0xfa, 0xcd, 0xb9, 0x0f, 0x0d, 0x41, 0xc9, 0xc4, 0x61, 0x24, 0x3b, 0x5c, 0xe7, 0x94,
	0xbd, 0x49, 0x59, 0x97, 0x04, 0x41, 0x37, 0x3a, 0xba, 0x36, 0xed, 0xc6, 0x3c, 0xc9, 0xcf, 0x5e,
	0x45, 0x2a, 0x78, 0xe3, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xbf, 0x2b, 0x3f, 0xca, 0xc9, 0x08,
	0x00, 0x00,
}

func (this *SessionEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&status.SessionEntry{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Gateway: "+fmt.Sprintf("%#v", this.Gateway)+",\n")
	s = append(s, "Expired: "+fmt.Sprintf("%#v", this.Expired)+",\n")
	s = append(s, "Layer: "+fmt.Sprintf("%#v", this.Layer)+",\n")
	s = append(s, "PermAuthKeyId: "+fmt.Sprintf("%#v", this.PermAuthKeyId)+",\n")
	s = append(s, "Client: "+fmt.Sprintf("%#v", this.Client)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&status.TLSessionEntry{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserSessionEntryList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&status.UserSessionEntryList{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	if this.UserSessions != nil {
		s = append(s, "UserSessions: "+fmt.Sprintf("%#v", this.UserSessions)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLUserSessionEntryList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&status.TLUserSessionEntryList{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLStatusSetSessionOnline) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&status.TLStatusSetSessionOnline{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	if this.Session != nil {
		s = append(s, "Session: "+fmt.Sprintf("%#v", this.Session)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLStatusSetSessionOffline) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&status.TLStatusSetSessionOffline{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLStatusGetUserOnlineSessions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&status.TLStatusGetUserOnlineSessions{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLStatusGetUsersOnlineSessionsList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&status.TLStatusGetUsersOnlineSessionsList{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Users: "+fmt.Sprintf("%#v", this.Users)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Vector_UserSessionEntryList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&status.Vector_UserSessionEntryList{")
	if this.Datas != nil {
		s = append(s, "Datas: "+fmt.Sprintf("%#v", this.Datas)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringStatusTl(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCStatusClient is the client API for RPCStatus service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCStatusClient interface {
	StatusSetSessionOnline(ctx context.Context, in *TLStatusSetSessionOnline, opts ...grpc.CallOption) (*mtproto.Bool, error)
	StatusSetSessionOffline(ctx context.Context, in *TLStatusSetSessionOffline, opts ...grpc.CallOption) (*mtproto.Bool, error)
	StatusGetUserOnlineSessions(ctx context.Context, in *TLStatusGetUserOnlineSessions, opts ...grpc.CallOption) (*UserSessionEntryList, error)
	StatusGetUsersOnlineSessionsList(ctx context.Context, in *TLStatusGetUsersOnlineSessionsList, opts ...grpc.CallOption) (*Vector_UserSessionEntryList, error)
}

type rPCStatusClient struct {
	cc *grpc.ClientConn
}

func NewRPCStatusClient(cc *grpc.ClientConn) RPCStatusClient {
	return &rPCStatusClient{cc}
}

func (c *rPCStatusClient) StatusSetSessionOnline(ctx context.Context, in *TLStatusSetSessionOnline, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/status.RPCStatus/status_setSessionOnline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCStatusClient) StatusSetSessionOffline(ctx context.Context, in *TLStatusSetSessionOffline, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/status.RPCStatus/status_setSessionOffline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCStatusClient) StatusGetUserOnlineSessions(ctx context.Context, in *TLStatusGetUserOnlineSessions, opts ...grpc.CallOption) (*UserSessionEntryList, error) {
	out := new(UserSessionEntryList)
	err := c.cc.Invoke(ctx, "/status.RPCStatus/status_getUserOnlineSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCStatusClient) StatusGetUsersOnlineSessionsList(ctx context.Context, in *TLStatusGetUsersOnlineSessionsList, opts ...grpc.CallOption) (*Vector_UserSessionEntryList, error) {
	out := new(Vector_UserSessionEntryList)
	err := c.cc.Invoke(ctx, "/status.RPCStatus/status_getUsersOnlineSessionsList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCStatusServer is the server API for RPCStatus service.
type RPCStatusServer interface {
	StatusSetSessionOnline(context.Context, *TLStatusSetSessionOnline) (*mtproto.Bool, error)
	StatusSetSessionOffline(context.Context, *TLStatusSetSessionOffline) (*mtproto.Bool, error)
	StatusGetUserOnlineSessions(context.Context, *TLStatusGetUserOnlineSessions) (*UserSessionEntryList, error)
	StatusGetUsersOnlineSessionsList(context.Context, *TLStatusGetUsersOnlineSessionsList) (*Vector_UserSessionEntryList, error)
}

// UnimplementedRPCStatusServer can be embedded to have forward compatible implementations.
type UnimplementedRPCStatusServer struct {
}

func (*UnimplementedRPCStatusServer) StatusSetSessionOnline(ctx context.Context, req *TLStatusSetSessionOnline) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusSetSessionOnline not implemented")
}
func (*UnimplementedRPCStatusServer) StatusSetSessionOffline(ctx context.Context, req *TLStatusSetSessionOffline) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusSetSessionOffline not implemented")
}
func (*UnimplementedRPCStatusServer) StatusGetUserOnlineSessions(ctx context.Context, req *TLStatusGetUserOnlineSessions) (*UserSessionEntryList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusGetUserOnlineSessions not implemented")
}
func (*UnimplementedRPCStatusServer) StatusGetUsersOnlineSessionsList(ctx context.Context, req *TLStatusGetUsersOnlineSessionsList) (*Vector_UserSessionEntryList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusGetUsersOnlineSessionsList not implemented")
}

func RegisterRPCStatusServer(s *grpc.Server, srv RPCStatusServer) {
	s.RegisterService(&_RPCStatus_serviceDesc, srv)
}

func _RPCStatus_StatusSetSessionOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLStatusSetSessionOnline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCStatusServer).StatusSetSessionOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/status.RPCStatus/StatusSetSessionOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCStatusServer).StatusSetSessionOnline(ctx, req.(*TLStatusSetSessionOnline))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCStatus_StatusSetSessionOffline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLStatusSetSessionOffline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCStatusServer).StatusSetSessionOffline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/status.RPCStatus/StatusSetSessionOffline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCStatusServer).StatusSetSessionOffline(ctx, req.(*TLStatusSetSessionOffline))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCStatus_StatusGetUserOnlineSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLStatusGetUserOnlineSessions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCStatusServer).StatusGetUserOnlineSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/status.RPCStatus/StatusGetUserOnlineSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCStatusServer).StatusGetUserOnlineSessions(ctx, req.(*TLStatusGetUserOnlineSessions))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCStatus_StatusGetUsersOnlineSessionsList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLStatusGetUsersOnlineSessionsList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCStatusServer).StatusGetUsersOnlineSessionsList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/status.RPCStatus/StatusGetUsersOnlineSessionsList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCStatusServer).StatusGetUsersOnlineSessionsList(ctx, req.(*TLStatusGetUsersOnlineSessionsList))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCStatus_serviceDesc = grpc.ServiceDesc{
	ServiceName: "status.RPCStatus",
	HandlerType: (*RPCStatusServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "status_setSessionOnline",
			Handler:    _RPCStatus_StatusSetSessionOnline_Handler,
		},
		{
			MethodName: "status_setSessionOffline",
			Handler:    _RPCStatus_StatusSetSessionOffline_Handler,
		},
		{
			MethodName: "status_getUserOnlineSessions",
			Handler:    _RPCStatus_StatusGetUserOnlineSessions_Handler,
		},
		{
			MethodName: "status_getUsersOnlineSessionsList",
			Handler:    _RPCStatus_StatusGetUsersOnlineSessionsList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "status.tl.proto",
}

func (m *SessionEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Client) > 0 {
		i -= len(m.Client)
		copy(dAtA[i:], m.Client)
		i = encodeVarintStatusTl(dAtA, i, uint64(len(m.Client)))
		i--
		dAtA[i] = 0x4a
	}
	if m.PermAuthKeyId != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.PermAuthKeyId))
		i--
		dAtA[i] = 0x40
	}
	if m.Layer != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x38
	}
	if m.Expired != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.Expired))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Gateway) > 0 {
		i -= len(m.Gateway)
		copy(dAtA[i:], m.Gateway)
		i = encodeVarintStatusTl(dAtA, i, uint64(len(m.Gateway)))
		i--
		dAtA[i] = 0x2a
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintStatusTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLSessionEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLSessionEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatusTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserSessionEntryList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSessionEntryList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSessionEntryList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserSessions) > 0 {
		for iNdEx := len(m.UserSessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserSessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatusTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.UserId != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintStatusTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLUserSessionEntryList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLUserSessionEntryList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLUserSessionEntryList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatusTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLStatusSetSessionOnline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLStatusSetSessionOnline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLStatusSetSessionOnline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatusTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UserId != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLStatusSetSessionOffline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLStatusSetSessionOffline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLStatusSetSessionOffline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLStatusGetUserOnlineSessions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLStatusGetUserOnlineSessions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLStatusGetUserOnlineSessions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLStatusGetUsersOnlineSessionsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLStatusGetUsersOnlineSessionsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLStatusGetUsersOnlineSessionsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Users) > 0 {
		dAtA5 := make([]byte, len(m.Users)*10)
		var j4 int
		for _, num1 := range m.Users {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintStatusTl(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintStatusTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vector_UserSessionEntryList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector_UserSessionEntryList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector_UserSessionEntryList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datas) > 0 {
		for iNdEx := len(m.Datas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Datas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatusTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintStatusTl(dAtA []byte, offset int, v uint64) int {
	offset -= sovStatusTl(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SessionEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovStatusTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovStatusTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovStatusTl(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovStatusTl(uint64(m.AuthKeyId))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovStatusTl(uint64(l))
	}
	if m.Expired != 0 {
		n += 1 + sovStatusTl(uint64(m.Expired))
	}
	if m.Layer != 0 {
		n += 1 + sovStatusTl(uint64(m.Layer))
	}
	if m.PermAuthKeyId != 0 {
		n += 1 + sovStatusTl(uint64(m.PermAuthKeyId))
	}
	l = len(m.Client)
	if l > 0 {
		n += 1 + l + sovStatusTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovStatusTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserSessionEntryList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovStatusTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovStatusTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovStatusTl(uint64(m.UserId))
	}
	if len(m.UserSessions) > 0 {
		for _, e := range m.UserSessions {
			l = e.Size()
			n += 1 + l + sovStatusTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLUserSessionEntryList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovStatusTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLStatusSetSessionOnline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovStatusTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovStatusTl(uint64(m.UserId))
	}
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovStatusTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLStatusSetSessionOffline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovStatusTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovStatusTl(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovStatusTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLStatusGetUserOnlineSessions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovStatusTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovStatusTl(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLStatusGetUsersOnlineSessionsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovStatusTl(uint64(m.Constructor))
	}
	if len(m.Users) > 0 {
		l = 0
		for _, e := range m.Users {
			l += sovStatusTl(uint64(e))
		}
		n += 1 + sovStatusTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vector_UserSessionEntryList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Datas) > 0 {
		for _, e := range m.Datas {
			l = e.Size()
			n += 1 + l + sovStatusTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovStatusTl(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStatusTl(x uint64) (n int) {
	return sovStatusTl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SessionEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatusTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatusTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatusTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatusTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatusTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expired", wireType)
			}
			m.Expired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expired |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermAuthKeyId", wireType)
			}
			m.PermAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermAuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatusTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatusTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Client = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatusTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatusTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatusTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_sessionEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_sessionEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatusTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatusTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &SessionEntry{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatusTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatusTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSessionEntryList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatusTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSessionEntryList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSessionEntryList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatusTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatusTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatusTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatusTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserSessions = append(m.UserSessions, &SessionEntry{})
			if err := m.UserSessions[len(m.UserSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatusTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatusTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLUserSessionEntryList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatusTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_userSessionEntryList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_userSessionEntryList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatusTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatusTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &UserSessionEntryList{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatusTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatusTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLStatusSetSessionOnline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatusTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_status_setSessionOnline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_status_setSessionOnline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatusTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatusTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &SessionEntry{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatusTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatusTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLStatusSetSessionOffline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatusTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_status_setSessionOffline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_status_setSessionOffline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatusTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatusTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLStatusGetUserOnlineSessions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatusTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_status_getUserOnlineSessions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_status_getUserOnlineSessions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatusTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatusTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLStatusGetUsersOnlineSessionsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatusTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_status_getUsersOnlineSessionsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_status_getUsersOnlineSessionsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatusTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Users = append(m.Users, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatusTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatusTl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthStatusTl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Users) == 0 {
					m.Users = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatusTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Users = append(m.Users, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatusTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatusTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector_UserSessionEntryList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatusTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector_UserSessionEntryList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector_UserSessionEntryList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatusTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatusTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datas = append(m.Datas, &UserSessionEntryList{})
			if err := m.Datas[len(m.Datas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatusTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatusTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStatusTl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStatusTl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatusTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStatusTl
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStatusTl
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStatusTl
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStatusTl        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStatusTl          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStatusTl = fmt.Errorf("proto: unexpected end of group")
)
