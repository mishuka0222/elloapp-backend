// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: media.tl.proto

package media

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	mtproto "github.com/teamgram/proto/mtproto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TLConstructor int32

const (
	CRC32_UNKNOWN                      TLConstructor = 0
	CRC32_photoSizeList                TLConstructor = 108083635
	CRC32_videoSizeList                TLConstructor = 953261042
	CRC32_media_uploadPhotoFile        TLConstructor = 1009453847
	CRC32_media_uploadProfilePhotoFile TLConstructor = -1757466844
	CRC32_media_getPhoto               TLConstructor = 1702803563
	CRC32_media_getPhotoSizeList       TLConstructor = -1578401979
	CRC32_media_getPhotoSizeListList   TLConstructor = -77823776
	CRC32_media_getVideoSizeList       TLConstructor = -998862102
	CRC32_media_uploadedDocumentMedia  TLConstructor = 1331671148
	CRC32_media_getDocument            TLConstructor = 1072011085
	CRC32_media_getDocumentList        TLConstructor = -986721681
	CRC32_media_uploadEncryptedFile    TLConstructor = -1426012517
	CRC32_media_getEncryptedFile       TLConstructor = -60784431
	CRC32_media_uploadWallPaperFile    TLConstructor = -1661293058
	CRC32_media_uploadThemeFile        TLConstructor = 1122416736
	CRC32_media_uploadStickerFile      TLConstructor = -1397349139
	CRC32_media_uploadRingtoneFile     TLConstructor = 1035645449
)

var TLConstructor_name = map[int32]string{
	0:           "CRC32_UNKNOWN",
	108083635:   "CRC32_photoSizeList",
	953261042:   "CRC32_videoSizeList",
	1009453847:  "CRC32_media_uploadPhotoFile",
	-1757466844: "CRC32_media_uploadProfilePhotoFile",
	1702803563:  "CRC32_media_getPhoto",
	-1578401979: "CRC32_media_getPhotoSizeList",
	-77823776:   "CRC32_media_getPhotoSizeListList",
	-998862102:  "CRC32_media_getVideoSizeList",
	1331671148:  "CRC32_media_uploadedDocumentMedia",
	1072011085:  "CRC32_media_getDocument",
	-986721681:  "CRC32_media_getDocumentList",
	-1426012517: "CRC32_media_uploadEncryptedFile",
	-60784431:   "CRC32_media_getEncryptedFile",
	-1661293058: "CRC32_media_uploadWallPaperFile",
	1122416736:  "CRC32_media_uploadThemeFile",
	-1397349139: "CRC32_media_uploadStickerFile",
	1035645449:  "CRC32_media_uploadRingtoneFile",
}

var TLConstructor_value = map[string]int32{
	"CRC32_UNKNOWN":                      0,
	"CRC32_photoSizeList":                108083635,
	"CRC32_videoSizeList":                953261042,
	"CRC32_media_uploadPhotoFile":        1009453847,
	"CRC32_media_uploadProfilePhotoFile": -1757466844,
	"CRC32_media_getPhoto":               1702803563,
	"CRC32_media_getPhotoSizeList":       -1578401979,
	"CRC32_media_getPhotoSizeListList":   -77823776,
	"CRC32_media_getVideoSizeList":       -998862102,
	"CRC32_media_uploadedDocumentMedia":  1331671148,
	"CRC32_media_getDocument":            1072011085,
	"CRC32_media_getDocumentList":        -986721681,
	"CRC32_media_uploadEncryptedFile":    -1426012517,
	"CRC32_media_getEncryptedFile":       -60784431,
	"CRC32_media_uploadWallPaperFile":    -1661293058,
	"CRC32_media_uploadThemeFile":        1122416736,
	"CRC32_media_uploadStickerFile":      -1397349139,
	"CRC32_media_uploadRingtoneFile":     1035645449,
}

func (x TLConstructor) String() string {
	return proto.EnumName(TLConstructor_name, int32(x))
}

func (TLConstructor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{0}
}

// PhotoSizeList <--
//  + TL_photoSizeList
//
type PhotoSizeList struct {
	PredicateName        string               `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor        `protobuf:"varint,2,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	SizeId               int64                `protobuf:"varint,3,opt,name=size_id,json=sizeId,proto3" json:"size_id,omitempty"`
	Sizes                []*mtproto.PhotoSize `protobuf:"bytes,4,rep,name=sizes,proto3" json:"sizes,omitempty"`
	DcId                 int32                `protobuf:"varint,5,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PhotoSizeList) Reset()         { *m = PhotoSizeList{} }
func (m *PhotoSizeList) String() string { return proto.CompactTextString(m) }
func (*PhotoSizeList) ProtoMessage()    {}
func (*PhotoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{0}
}
func (m *PhotoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhotoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhotoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhotoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhotoSizeList.Merge(m, src)
}
func (m *PhotoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *PhotoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_PhotoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_PhotoSizeList proto.InternalMessageInfo

func (m *PhotoSizeList) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *PhotoSizeList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *PhotoSizeList) GetSizeId() int64 {
	if m != nil {
		return m.SizeId
	}
	return 0
}

func (m *PhotoSizeList) GetSizes() []*mtproto.PhotoSize {
	if m != nil {
		return m.Sizes
	}
	return nil
}

func (m *PhotoSizeList) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

type TLPhotoSizeList struct {
	Data2                *PhotoSizeList `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLPhotoSizeList) Reset()         { *m = TLPhotoSizeList{} }
func (m *TLPhotoSizeList) String() string { return proto.CompactTextString(m) }
func (*TLPhotoSizeList) ProtoMessage()    {}
func (*TLPhotoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{1}
}
func (m *TLPhotoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLPhotoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLPhotoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLPhotoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLPhotoSizeList.Merge(m, src)
}
func (m *TLPhotoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *TLPhotoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLPhotoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_TLPhotoSizeList proto.InternalMessageInfo

func (m *TLPhotoSizeList) GetData2() *PhotoSizeList {
	if m != nil {
		return m.Data2
	}
	return nil
}

// VideoSizeList <--
//  + TL_videoSizeList
//
type VideoSizeList struct {
	PredicateName        string               `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor        `protobuf:"varint,2,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	SizeId               int64                `protobuf:"varint,3,opt,name=size_id,json=sizeId,proto3" json:"size_id,omitempty"`
	Sizes                []*mtproto.VideoSize `protobuf:"bytes,4,rep,name=sizes,proto3" json:"sizes,omitempty"`
	DcId                 int32                `protobuf:"varint,5,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *VideoSizeList) Reset()         { *m = VideoSizeList{} }
func (m *VideoSizeList) String() string { return proto.CompactTextString(m) }
func (*VideoSizeList) ProtoMessage()    {}
func (*VideoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{2}
}
func (m *VideoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoSizeList.Merge(m, src)
}
func (m *VideoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *VideoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_VideoSizeList proto.InternalMessageInfo

func (m *VideoSizeList) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *VideoSizeList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *VideoSizeList) GetSizeId() int64 {
	if m != nil {
		return m.SizeId
	}
	return 0
}

func (m *VideoSizeList) GetSizes() []*mtproto.VideoSize {
	if m != nil {
		return m.Sizes
	}
	return nil
}

func (m *VideoSizeList) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

type TLVideoSizeList struct {
	Data2                *VideoSizeList `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLVideoSizeList) Reset()         { *m = TLVideoSizeList{} }
func (m *TLVideoSizeList) String() string { return proto.CompactTextString(m) }
func (*TLVideoSizeList) ProtoMessage()    {}
func (*TLVideoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{3}
}
func (m *TLVideoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLVideoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLVideoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLVideoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLVideoSizeList.Merge(m, src)
}
func (m *TLVideoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *TLVideoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLVideoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_TLVideoSizeList proto.InternalMessageInfo

func (m *TLVideoSizeList) GetData2() *VideoSizeList {
	if m != nil {
		return m.Data2
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLMediaUploadPhotoFile struct {
	Constructor          TLConstructor            `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64                    `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                 *mtproto.InputFile       `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	Stickers             []*mtproto.InputDocument `protobuf:"bytes,5,rep,name=stickers,proto3" json:"stickers,omitempty"`
	TtlSeconds           *types.Int32Value        `protobuf:"bytes,6,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TLMediaUploadPhotoFile) Reset()         { *m = TLMediaUploadPhotoFile{} }
func (m *TLMediaUploadPhotoFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadPhotoFile) ProtoMessage()    {}
func (*TLMediaUploadPhotoFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{4}
}
func (m *TLMediaUploadPhotoFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadPhotoFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadPhotoFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadPhotoFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadPhotoFile.Merge(m, src)
}
func (m *TLMediaUploadPhotoFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadPhotoFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadPhotoFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadPhotoFile proto.InternalMessageInfo

func (m *TLMediaUploadPhotoFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadPhotoFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadPhotoFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLMediaUploadPhotoFile) GetStickers() []*mtproto.InputDocument {
	if m != nil {
		return m.Stickers
	}
	return nil
}

func (m *TLMediaUploadPhotoFile) GetTtlSeconds() *types.Int32Value {
	if m != nil {
		return m.TtlSeconds
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLMediaUploadProfilePhotoFile struct {
	Constructor          TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64              `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                 *mtproto.InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	Video                *mtproto.InputFile `protobuf:"bytes,5,opt,name=video,proto3" json:"video,omitempty"`
	VideoStartTs         *types.DoubleValue `protobuf:"bytes,6,opt,name=video_start_ts,json=videoStartTs,proto3" json:"video_start_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLMediaUploadProfilePhotoFile) Reset()         { *m = TLMediaUploadProfilePhotoFile{} }
func (m *TLMediaUploadProfilePhotoFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadProfilePhotoFile) ProtoMessage()    {}
func (*TLMediaUploadProfilePhotoFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{5}
}
func (m *TLMediaUploadProfilePhotoFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadProfilePhotoFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadProfilePhotoFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadProfilePhotoFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadProfilePhotoFile.Merge(m, src)
}
func (m *TLMediaUploadProfilePhotoFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadProfilePhotoFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadProfilePhotoFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadProfilePhotoFile proto.InternalMessageInfo

func (m *TLMediaUploadProfilePhotoFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadProfilePhotoFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadProfilePhotoFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLMediaUploadProfilePhotoFile) GetVideo() *mtproto.InputFile {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *TLMediaUploadProfilePhotoFile) GetVideoStartTs() *types.DoubleValue {
	if m != nil {
		return m.VideoStartTs
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLMediaGetPhoto struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	PhotoId              int64         `protobuf:"varint,3,opt,name=photo_id,json=photoId,proto3" json:"photo_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetPhoto) Reset()         { *m = TLMediaGetPhoto{} }
func (m *TLMediaGetPhoto) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetPhoto) ProtoMessage()    {}
func (*TLMediaGetPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{6}
}
func (m *TLMediaGetPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetPhoto.Merge(m, src)
}
func (m *TLMediaGetPhoto) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetPhoto proto.InternalMessageInfo

func (m *TLMediaGetPhoto) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetPhoto) GetPhotoId() int64 {
	if m != nil {
		return m.PhotoId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLMediaGetPhotoSizeList struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	SizeId               int64         `protobuf:"varint,3,opt,name=size_id,json=sizeId,proto3" json:"size_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetPhotoSizeList) Reset()         { *m = TLMediaGetPhotoSizeList{} }
func (m *TLMediaGetPhotoSizeList) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetPhotoSizeList) ProtoMessage()    {}
func (*TLMediaGetPhotoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{7}
}
func (m *TLMediaGetPhotoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetPhotoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetPhotoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetPhotoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetPhotoSizeList.Merge(m, src)
}
func (m *TLMediaGetPhotoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetPhotoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetPhotoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetPhotoSizeList proto.InternalMessageInfo

func (m *TLMediaGetPhotoSizeList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetPhotoSizeList) GetSizeId() int64 {
	if m != nil {
		return m.SizeId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLMediaGetPhotoSizeListList struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	IdList               []int64       `protobuf:"varint,3,rep,packed,name=id_list,json=idList,proto3" json:"id_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetPhotoSizeListList) Reset()         { *m = TLMediaGetPhotoSizeListList{} }
func (m *TLMediaGetPhotoSizeListList) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetPhotoSizeListList) ProtoMessage()    {}
func (*TLMediaGetPhotoSizeListList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{8}
}
func (m *TLMediaGetPhotoSizeListList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetPhotoSizeListList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetPhotoSizeListList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetPhotoSizeListList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetPhotoSizeListList.Merge(m, src)
}
func (m *TLMediaGetPhotoSizeListList) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetPhotoSizeListList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetPhotoSizeListList.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetPhotoSizeListList proto.InternalMessageInfo

func (m *TLMediaGetPhotoSizeListList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetPhotoSizeListList) GetIdList() []int64 {
	if m != nil {
		return m.IdList
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLMediaGetVideoSizeList struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	SizeId               int64         `protobuf:"varint,3,opt,name=size_id,json=sizeId,proto3" json:"size_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetVideoSizeList) Reset()         { *m = TLMediaGetVideoSizeList{} }
func (m *TLMediaGetVideoSizeList) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetVideoSizeList) ProtoMessage()    {}
func (*TLMediaGetVideoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{9}
}
func (m *TLMediaGetVideoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetVideoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetVideoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetVideoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetVideoSizeList.Merge(m, src)
}
func (m *TLMediaGetVideoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetVideoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetVideoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetVideoSizeList proto.InternalMessageInfo

func (m *TLMediaGetVideoSizeList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetVideoSizeList) GetSizeId() int64 {
	if m != nil {
		return m.SizeId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLMediaUploadedDocumentMedia struct {
	Constructor          TLConstructor       `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64               `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	Media                *mtproto.InputMedia `protobuf:"bytes,4,opt,name=media,proto3" json:"media,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TLMediaUploadedDocumentMedia) Reset()         { *m = TLMediaUploadedDocumentMedia{} }
func (m *TLMediaUploadedDocumentMedia) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadedDocumentMedia) ProtoMessage()    {}
func (*TLMediaUploadedDocumentMedia) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{10}
}
func (m *TLMediaUploadedDocumentMedia) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadedDocumentMedia) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadedDocumentMedia.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadedDocumentMedia) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadedDocumentMedia.Merge(m, src)
}
func (m *TLMediaUploadedDocumentMedia) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadedDocumentMedia) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadedDocumentMedia.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadedDocumentMedia proto.InternalMessageInfo

func (m *TLMediaUploadedDocumentMedia) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadedDocumentMedia) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadedDocumentMedia) GetMedia() *mtproto.InputMedia {
	if m != nil {
		return m.Media
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLMediaGetDocument struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	Id                   int64         `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetDocument) Reset()         { *m = TLMediaGetDocument{} }
func (m *TLMediaGetDocument) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetDocument) ProtoMessage()    {}
func (*TLMediaGetDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{11}
}
func (m *TLMediaGetDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetDocument.Merge(m, src)
}
func (m *TLMediaGetDocument) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetDocument.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetDocument proto.InternalMessageInfo

func (m *TLMediaGetDocument) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetDocument) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLMediaGetDocumentList struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	IdList               []int64       `protobuf:"varint,3,rep,packed,name=id_list,json=idList,proto3" json:"id_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetDocumentList) Reset()         { *m = TLMediaGetDocumentList{} }
func (m *TLMediaGetDocumentList) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetDocumentList) ProtoMessage()    {}
func (*TLMediaGetDocumentList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{12}
}
func (m *TLMediaGetDocumentList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetDocumentList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetDocumentList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetDocumentList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetDocumentList.Merge(m, src)
}
func (m *TLMediaGetDocumentList) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetDocumentList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetDocumentList.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetDocumentList proto.InternalMessageInfo

func (m *TLMediaGetDocumentList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetDocumentList) GetIdList() []int64 {
	if m != nil {
		return m.IdList
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLMediaUploadEncryptedFile struct {
	Constructor          TLConstructor               `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64                       `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                 *mtproto.InputEncryptedFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *TLMediaUploadEncryptedFile) Reset()         { *m = TLMediaUploadEncryptedFile{} }
func (m *TLMediaUploadEncryptedFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadEncryptedFile) ProtoMessage()    {}
func (*TLMediaUploadEncryptedFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{13}
}
func (m *TLMediaUploadEncryptedFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadEncryptedFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadEncryptedFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadEncryptedFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadEncryptedFile.Merge(m, src)
}
func (m *TLMediaUploadEncryptedFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadEncryptedFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadEncryptedFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadEncryptedFile proto.InternalMessageInfo

func (m *TLMediaUploadEncryptedFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadEncryptedFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadEncryptedFile) GetFile() *mtproto.InputEncryptedFile {
	if m != nil {
		return m.File
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLMediaGetEncryptedFile struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	Id                   int64         `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	AccessHash           int64         `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetEncryptedFile) Reset()         { *m = TLMediaGetEncryptedFile{} }
func (m *TLMediaGetEncryptedFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetEncryptedFile) ProtoMessage()    {}
func (*TLMediaGetEncryptedFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{14}
}
func (m *TLMediaGetEncryptedFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetEncryptedFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetEncryptedFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetEncryptedFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetEncryptedFile.Merge(m, src)
}
func (m *TLMediaGetEncryptedFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetEncryptedFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetEncryptedFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetEncryptedFile proto.InternalMessageInfo

func (m *TLMediaGetEncryptedFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetEncryptedFile) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TLMediaGetEncryptedFile) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLMediaUploadWallPaperFile struct {
	Constructor          TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64              `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                 *mtproto.InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	MimeType             string             `protobuf:"bytes,5,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	Admin                *mtproto.Bool      `protobuf:"bytes,6,opt,name=admin,proto3" json:"admin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLMediaUploadWallPaperFile) Reset()         { *m = TLMediaUploadWallPaperFile{} }
func (m *TLMediaUploadWallPaperFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadWallPaperFile) ProtoMessage()    {}
func (*TLMediaUploadWallPaperFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{15}
}
func (m *TLMediaUploadWallPaperFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadWallPaperFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadWallPaperFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadWallPaperFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadWallPaperFile.Merge(m, src)
}
func (m *TLMediaUploadWallPaperFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadWallPaperFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadWallPaperFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadWallPaperFile proto.InternalMessageInfo

func (m *TLMediaUploadWallPaperFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadWallPaperFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadWallPaperFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLMediaUploadWallPaperFile) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *TLMediaUploadWallPaperFile) GetAdmin() *mtproto.Bool {
	if m != nil {
		return m.Admin
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLMediaUploadThemeFile struct {
	Constructor          TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64              `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                 *mtproto.InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	Thumb                *mtproto.InputFile `protobuf:"bytes,5,opt,name=thumb,proto3" json:"thumb,omitempty"`
	MimeType             string             `protobuf:"bytes,6,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileName             string             `protobuf:"bytes,7,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLMediaUploadThemeFile) Reset()         { *m = TLMediaUploadThemeFile{} }
func (m *TLMediaUploadThemeFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadThemeFile) ProtoMessage()    {}
func (*TLMediaUploadThemeFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{16}
}
func (m *TLMediaUploadThemeFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadThemeFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadThemeFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadThemeFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadThemeFile.Merge(m, src)
}
func (m *TLMediaUploadThemeFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadThemeFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadThemeFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadThemeFile proto.InternalMessageInfo

func (m *TLMediaUploadThemeFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadThemeFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadThemeFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLMediaUploadThemeFile) GetThumb() *mtproto.InputFile {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *TLMediaUploadThemeFile) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *TLMediaUploadThemeFile) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

//--------------------------------------------------------------------------------------------
type TLMediaUploadStickerFile struct {
	Constructor              TLConstructor              `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId                  int64                      `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                     *mtproto.InputFile         `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	Thumb                    *mtproto.InputFile         `protobuf:"bytes,5,opt,name=thumb,proto3" json:"thumb,omitempty"`
	MimeType                 string                     `protobuf:"bytes,6,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileName                 string                     `protobuf:"bytes,7,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	DocumentAttributeSticker *mtproto.DocumentAttribute `protobuf:"bytes,8,opt,name=document_attribute_sticker,json=documentAttributeSticker,proto3" json:"document_attribute_sticker,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}                   `json:"-"`
	XXX_unrecognized         []byte                     `json:"-"`
	XXX_sizecache            int32                      `json:"-"`
}

func (m *TLMediaUploadStickerFile) Reset()         { *m = TLMediaUploadStickerFile{} }
func (m *TLMediaUploadStickerFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadStickerFile) ProtoMessage()    {}
func (*TLMediaUploadStickerFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{17}
}
func (m *TLMediaUploadStickerFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadStickerFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadStickerFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadStickerFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadStickerFile.Merge(m, src)
}
func (m *TLMediaUploadStickerFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadStickerFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadStickerFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadStickerFile proto.InternalMessageInfo

func (m *TLMediaUploadStickerFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadStickerFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadStickerFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLMediaUploadStickerFile) GetThumb() *mtproto.InputFile {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *TLMediaUploadStickerFile) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *TLMediaUploadStickerFile) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *TLMediaUploadStickerFile) GetDocumentAttributeSticker() *mtproto.DocumentAttribute {
	if m != nil {
		return m.DocumentAttributeSticker
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLMediaUploadRingtoneFile struct {
	Constructor          TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64              `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                 *mtproto.InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	MimeType             string             `protobuf:"bytes,5,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileName             string             `protobuf:"bytes,6,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLMediaUploadRingtoneFile) Reset()         { *m = TLMediaUploadRingtoneFile{} }
func (m *TLMediaUploadRingtoneFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadRingtoneFile) ProtoMessage()    {}
func (*TLMediaUploadRingtoneFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{18}
}
func (m *TLMediaUploadRingtoneFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadRingtoneFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadRingtoneFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadRingtoneFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadRingtoneFile.Merge(m, src)
}
func (m *TLMediaUploadRingtoneFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadRingtoneFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadRingtoneFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadRingtoneFile proto.InternalMessageInfo

func (m *TLMediaUploadRingtoneFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadRingtoneFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadRingtoneFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLMediaUploadRingtoneFile) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *TLMediaUploadRingtoneFile) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

//--------------------------------------------------------------------------------------------
// Vector api result type
type Vector_PhotoSizeList struct {
	Datas                []*PhotoSizeList `protobuf:"bytes,1,rep,name=datas,proto3" json:"datas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Vector_PhotoSizeList) Reset()         { *m = Vector_PhotoSizeList{} }
func (m *Vector_PhotoSizeList) String() string { return proto.CompactTextString(m) }
func (*Vector_PhotoSizeList) ProtoMessage()    {}
func (*Vector_PhotoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{19}
}
func (m *Vector_PhotoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector_PhotoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector_PhotoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector_PhotoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector_PhotoSizeList.Merge(m, src)
}
func (m *Vector_PhotoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *Vector_PhotoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector_PhotoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_Vector_PhotoSizeList proto.InternalMessageInfo

func (m *Vector_PhotoSizeList) GetDatas() []*PhotoSizeList {
	if m != nil {
		return m.Datas
	}
	return nil
}

type Vector_Document struct {
	Datas                []*mtproto.Document `protobuf:"bytes,1,rep,name=datas,proto3" json:"datas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Vector_Document) Reset()         { *m = Vector_Document{} }
func (m *Vector_Document) String() string { return proto.CompactTextString(m) }
func (*Vector_Document) ProtoMessage()    {}
func (*Vector_Document) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{20}
}
func (m *Vector_Document) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector_Document) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector_Document.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector_Document) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector_Document.Merge(m, src)
}
func (m *Vector_Document) XXX_Size() int {
	return m.Size()
}
func (m *Vector_Document) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector_Document.DiscardUnknown(m)
}

var xxx_messageInfo_Vector_Document proto.InternalMessageInfo

func (m *Vector_Document) GetDatas() []*mtproto.Document {
	if m != nil {
		return m.Datas
	}
	return nil
}

func init() {
	proto.RegisterEnum("media.TLConstructor", TLConstructor_name, TLConstructor_value)
	proto.RegisterType((*PhotoSizeList)(nil), "media.PhotoSizeList")
	proto.RegisterType((*TLPhotoSizeList)(nil), "media.TL_photoSizeList")
	proto.RegisterType((*VideoSizeList)(nil), "media.VideoSizeList")
	proto.RegisterType((*TLVideoSizeList)(nil), "media.TL_videoSizeList")
	proto.RegisterType((*TLMediaUploadPhotoFile)(nil), "media.TL_media_uploadPhotoFile")
	proto.RegisterType((*TLMediaUploadProfilePhotoFile)(nil), "media.TL_media_uploadProfilePhotoFile")
	proto.RegisterType((*TLMediaGetPhoto)(nil), "media.TL_media_getPhoto")
	proto.RegisterType((*TLMediaGetPhotoSizeList)(nil), "media.TL_media_getPhotoSizeList")
	proto.RegisterType((*TLMediaGetPhotoSizeListList)(nil), "media.TL_media_getPhotoSizeListList")
	proto.RegisterType((*TLMediaGetVideoSizeList)(nil), "media.TL_media_getVideoSizeList")
	proto.RegisterType((*TLMediaUploadedDocumentMedia)(nil), "media.TL_media_uploadedDocumentMedia")
	proto.RegisterType((*TLMediaGetDocument)(nil), "media.TL_media_getDocument")
	proto.RegisterType((*TLMediaGetDocumentList)(nil), "media.TL_media_getDocumentList")
	proto.RegisterType((*TLMediaUploadEncryptedFile)(nil), "media.TL_media_uploadEncryptedFile")
	proto.RegisterType((*TLMediaGetEncryptedFile)(nil), "media.TL_media_getEncryptedFile")
	proto.RegisterType((*TLMediaUploadWallPaperFile)(nil), "media.TL_media_uploadWallPaperFile")
	proto.RegisterType((*TLMediaUploadThemeFile)(nil), "media.TL_media_uploadThemeFile")
	proto.RegisterType((*TLMediaUploadStickerFile)(nil), "media.TL_media_uploadStickerFile")
	proto.RegisterType((*TLMediaUploadRingtoneFile)(nil), "media.TL_media_uploadRingtoneFile")
	proto.RegisterType((*Vector_PhotoSizeList)(nil), "media.Vector_PhotoSizeList")
	proto.RegisterType((*Vector_Document)(nil), "media.Vector_Document")
}

func init() { proto.RegisterFile("media.tl.proto", fileDescriptor_c788ef787fa9e2c6) }

var fileDescriptor_c788ef787fa9e2c6 = []byte{
	// 1491 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x4d, 0x68, 0xdc, 0xd6,
	0x16, 0xb6, 0x3c, 0x1e, 0xc7, 0x3e, 0x7e, 0xf6, 0x93, 0x6f, 0x9c, 0x44, 0xd6, 0x38, 0xe3, 0x89,
	0xf2, 0x92, 0x37, 0x09, 0x2f, 0x33, 0x30, 0x86, 0xb7, 0x68, 0x43, 0xa1, 0x76, 0x52, 0xea, 0xd6,
	0x76, 0x5d, 0x79, 0xf2, 0x43, 0xa0, 0x15, 0xb2, 0x74, 0x33, 0x23, 0xa2, 0x19, 0x09, 0xe9, 0x4e,
	0x82, 0xb3, 0x4b, 0x5b, 0xe8, 0x0f, 0x94, 0xee, 0x12, 0x68, 0xa1, 0x8b, 0x26, 0x5d, 0x94, 0xfe,
	0x6c, 0xba, 0x28, 0x5d, 0x75, 0xd3, 0x86, 0x76, 0x51, 0x48, 0x0b, 0x85, 0x90, 0x40, 0x71, 0xd2,
	0x96, 0x42, 0xda, 0xd0, 0x90, 0xac, 0x62, 0x42, 0xa6, 0xe8, 0x6a, 0xa4, 0x99, 0xab, 0xd1, 0x4c,
	0x43, 0x7e, 0xa8, 0xa1, 0x9b, 0x41, 0xba, 0xe7, 0xd3, 0x77, 0xce, 0xf9, 0xee, 0xbd, 0xe7, 0x9e,
	0x3b, 0x30, 0x52, 0xc1, 0xba, 0xa1, 0xe6, 0x88, 0x99, 0xb3, 0x1d, 0x8b, 0x58, 0x28, 0x49, 0xdf,
	0xc5, 0x3d, 0x25, 0x83, 0x94, 0x6b, 0xcb, 0x39, 0xcd, 0xaa, 0xe4, 0x4b, 0x56, 0xc9, 0xca, 0x53,
	0xeb, 0x72, 0xed, 0x28, 0x7d, 0xa3, 0x2f, 0xf4, 0xc9, 0xff, 0x4a, 0x4c, 0x97, 0x2c, 0xab, 0x64,
	0xe2, 0x26, 0xea, 0x84, 0xa3, 0xda, 0x36, 0x76, 0xdc, 0x86, 0x5d, 0x74, 0xb5, 0x32, 0xae, 0x50,
	0x37, 0x9a, 0xe5, 0x60, 0x85, 0xac, 0xd8, 0x38, 0xb0, 0x8d, 0x37, 0x6d, 0xc4, 0x51, 0xab, 0xae,
	0x6d, 0x39, 0xa4, 0x61, 0x1a, 0x6b, 0x9a, 0xdc, 0x95, 0xaa, 0xe6, 0x8f, 0x4a, 0xe7, 0x39, 0x18,
	0x5e, 0x2c, 0x5b, 0xc4, 0x5a, 0x32, 0x4e, 0xe2, 0x39, 0xc3, 0x25, 0x68, 0x07, 0x8c, 0xd8, 0x0e,
	0xd6, 0x0d, 0x4d, 0x25, 0x58, 0xa9, 0xaa, 0x15, 0x2c, 0x70, 0x19, 0x2e, 0x3b, 0x28, 0x0f, 0x87,
	0xa3, 0x0b, 0x6a, 0x05, 0xa3, 0xff, 0xc3, 0x90, 0x66, 0x55, 0x5d, 0xe2, 0xd4, 0x34, 0x62, 0x39,
	0x42, 0x6f, 0x86, 0xcb, 0x8e, 0x14, 0xc6, 0x72, 0xbe, 0x02, 0xc5, 0xb9, 0x99, 0xa6, 0x4d, 0x6e,
	0x05, 0xa2, 0x2d, 0xb0, 0xc1, 0x35, 0x4e, 0x62, 0xc5, 0xd0, 0x85, 0x44, 0x86, 0xcb, 0x26, 0xe4,
	0x7e, 0xef, 0x75, 0x56, 0x47, 0x59, 0x48, 0x7a, 0x4f, 0xae, 0xd0, 0x97, 0x49, 0x64, 0x87, 0x0a,
	0x28, 0x57, 0x21, 0x34, 0xc4, 0x5c, 0x18, 0x9e, 0xec, 0x03, 0xd0, 0x46, 0x48, 0xea, 0x9a, 0x47,
	0x90, 0xcc, 0x70, 0xd9, 0xa4, 0xdc, 0xa7, 0x6b, 0xb3, 0xba, 0xf4, 0x04, 0xf0, 0xc5, 0x39, 0xc5,
	0x66, 0x52, 0xd9, 0x0d, 0x49, 0x5d, 0x25, 0x6a, 0x81, 0x66, 0x30, 0x14, 0x46, 0xc7, 0xe4, 0x2b,
	0xfb, 0x10, 0x2a, 0xc4, 0x41, 0x43, 0xc7, 0xeb, 0x58, 0x88, 0x30, 0xbc, 0x7b, 0x10, 0xe2, 0x38,
	0x93, 0x4a, 0x07, 0x21, 0x98, 0x7c, 0x03, 0x21, 0x5e, 0xed, 0x05, 0xa1, 0x38, 0xa7, 0x50, 0x84,
	0x52, 0xb3, 0x4d, 0x4b, 0xd5, 0xa9, 0x60, 0x4f, 0x19, 0x66, 0x5b, 0xb2, 0xdc, 0xbd, 0x26, 0x3b,
	0x0e, 0x03, 0xd6, 0x89, 0x2a, 0x76, 0x9a, 0xd9, 0x6e, 0xa0, 0xef, 0xb3, 0x3a, 0xda, 0x09, 0x7d,
	0x47, 0x0d, 0x13, 0x0b, 0x7d, 0x34, 0xb4, 0x66, 0xb6, 0xb3, 0x55, 0xbb, 0x46, 0x3c, 0xa7, 0x32,
	0xb5, 0xa3, 0x02, 0x0c, 0xb8, 0xc4, 0xd0, 0x8e, 0x61, 0xc7, 0x15, 0x92, 0x54, 0x99, 0xcd, 0x2c,
	0x76, 0x9f, 0xa5, 0xd5, 0x2a, 0xb8, 0x4a, 0xe4, 0x10, 0x87, 0xf6, 0xc2, 0x10, 0x21, 0xa6, 0xe2,
	0x62, 0xcd, 0xaa, 0xea, 0xae, 0xd0, 0x4f, 0x5d, 0xa4, 0x72, 0xfe, 0x06, 0xcb, 0x05, 0x1b, 0x2c,
	0x37, 0x5b, 0x25, 0x53, 0x85, 0x83, 0xaa, 0x59, 0xc3, 0x32, 0x10, 0x62, 0x2e, 0xf9, 0x70, 0xe9,
	0x8d, 0x5e, 0x98, 0x8c, 0x2a, 0xe1, 0x58, 0x5e, 0x30, 0xeb, 0x42, 0x90, 0x2c, 0x24, 0xe9, 0x2c,
	0xd3, 0xd9, 0x8f, 0x07, 0xfa, 0x00, 0x34, 0x0d, 0x23, 0xf4, 0x41, 0x71, 0x89, 0xea, 0x10, 0x85,
	0x04, 0x4a, 0x4c, 0xb4, 0x29, 0xb1, 0xcf, 0xaa, 0x2d, 0x9b, 0xd8, 0x97, 0xe2, 0x5f, 0xfe, 0x1a,
	0xf2, 0x3e, 0x29, 0xba, 0xd2, 0x51, 0x18, 0x0d, 0xb5, 0x28, 0x61, 0x42, 0x15, 0x78, 0x90, 0xec,
	0xe9, 0x4e, 0x6d, 0xc9, 0x9e, 0xbe, 0xcf, 0xea, 0x92, 0x09, 0xe3, 0x6d, 0x7e, 0xc2, 0x75, 0x7c,
	0xbf, 0xfe, 0x3a, 0xed, 0x35, 0xc9, 0x86, 0xad, 0x1d, 0xbd, 0x3d, 0xa8, 0x47, 0x43, 0x57, 0x4c,
	0xc3, 0x25, 0x42, 0x22, 0x93, 0xf0, 0x3c, 0x1a, 0xba, 0x47, 0x18, 0xcd, 0x8f, 0x2d, 0x39, 0x0f,
	0x3d, 0xbf, 0x77, 0x39, 0x48, 0x47, 0x96, 0x30, 0xd6, 0x83, 0x8d, 0x32, 0xef, 0x8d, 0x3e, 0x8a,
	0x15, 0xbc, 0x0b, 0xfc, 0x93, 0xaf, 0xb1, 0x84, 0x37, 0xb2, 0x2b, 0x93, 0xba, 0x95, 0x7d, 0x84,
	0xf4, 0x22, 0x8c, 0xb5, 0xca, 0x11, 0x84, 0x76, 0xdf, 0x51, 0x8d, 0x40, 0x6f, 0x18, 0x4f, 0xaf,
	0xa1, 0x4b, 0xc7, 0x5a, 0x8a, 0x59, 0x0b, 0xff, 0xa3, 0x99, 0xdb, 0xf7, 0x38, 0x98, 0x88, 0xa8,
	0xbd, 0xbf, 0xaa, 0x39, 0x2b, 0x36, 0xc1, 0xfa, 0xa3, 0xaa, 0x16, 0x79, 0xa6, 0x5a, 0xa4, 0x58,
	0xa9, 0x19, 0xef, 0x7e, 0xd9, 0x90, 0x5e, 0xe1, 0xd8, 0x15, 0xf8, 0x70, 0x22, 0x8c, 0xe8, 0x8e,
	0x26, 0x61, 0x48, 0xd5, 0x34, 0xec, 0xba, 0x4a, 0x59, 0x75, 0xcb, 0x34, 0xba, 0x84, 0x0c, 0xfe,
	0xd0, 0xd3, 0xaa, 0x5b, 0x96, 0x2e, 0xb7, 0x6b, 0x75, 0x48, 0x35, 0xcd, 0x45, 0xd5, 0xc6, 0xce,
	0xdf, 0x5d, 0x59, 0x53, 0x30, 0x58, 0x31, 0x2a, 0x7e, 0x67, 0x45, 0xab, 0xeb, 0xa0, 0x3c, 0xe0,
	0x0d, 0x14, 0x57, 0x6c, 0x8c, 0xb6, 0x43, 0x52, 0xd5, 0x2b, 0x46, 0xb5, 0x51, 0x43, 0x87, 0x43,
	0x96, 0x69, 0xcb, 0x32, 0x65, 0xdf, 0x26, 0xdd, 0xe6, 0xda, 0x0e, 0xd1, 0x62, 0x19, 0x57, 0xf0,
	0x3a, 0x38, 0x33, 0x48, 0xb9, 0x56, 0x59, 0xee, 0x76, 0x66, 0x50, 0x00, 0xab, 0x41, 0x7f, 0x44,
	0x83, 0x14, 0x0c, 0x7a, 0x74, 0x7e, 0x57, 0xb4, 0xc1, 0x37, 0x7a, 0x03, 0x5e, 0x43, 0x24, 0xfd,
	0xd0, 0x0b, 0x62, 0x24, 0xf7, 0x25, 0xff, 0x40, 0xfe, 0x07, 0x64, 0x8f, 0x0e, 0x83, 0xa8, 0x37,
	0x8a, 0x8c, 0xa2, 0x12, 0xe2, 0x18, 0xcb, 0x35, 0x82, 0x95, 0x46, 0x47, 0x22, 0x0c, 0x50, 0xc7,
	0x62, 0xe8, 0x38, 0xa8, 0x47, 0x4f, 0x06, 0x48, 0x59, 0xd0, 0xa3, 0x43, 0x0d, 0xf1, 0xa4, 0xef,
	0x39, 0x48, 0x45, 0x74, 0x95, 0x8d, 0x6a, 0x89, 0x58, 0x55, 0xbc, 0xae, 0x37, 0x0c, 0x23, 0x57,
	0x7f, 0x64, 0xb1, 0x4c, 0xc3, 0xd8, 0x41, 0xec, 0x85, 0xa1, 0x2c, 0xc6, 0xb5, 0xee, 0xae, 0xc0,
	0xd1, 0x56, 0xaf, 0x4b, 0xeb, 0xee, 0x4a, 0x8f, 0xc1, 0xbf, 0x1b, 0x1c, 0xe1, 0xf1, 0xf1, 0x5f,
	0xf6, 0xf3, 0xd1, 0x36, 0xc1, 0x1b, 0xdf, 0xee, 0xbe, 0x90, 0x84, 0x61, 0x46, 0x1b, 0x34, 0x0a,
	0xc3, 0x33, 0xf2, 0xcc, 0x54, 0x41, 0x39, 0xb0, 0xf0, 0xec, 0xc2, 0x73, 0x87, 0x16, 0xf8, 0x1e,
	0x24, 0xc2, 0x46, 0x7f, 0x88, 0xb9, 0x5e, 0xf0, 0x9f, 0xde, 0xfa, 0x72, 0x0a, 0xa5, 0x02, 0x1b,
	0xd3, 0x71, 0xf3, 0x37, 0x3f, 0x3b, 0x7f, 0x3e, 0x81, 0xb6, 0x43, 0xca, 0x37, 0xc6, 0x76, 0xd3,
	0xfc, 0x99, 0xd3, 0x1f, 0x5d, 0x49, 0xa0, 0x3c, 0x48, 0x31, 0xa0, 0x48, 0xa3, 0xc9, 0x9f, 0xfb,
	0xf1, 0xce, 0xe7, 0xb7, 0xeb, 0xf5, 0x7a, 0x9d, 0x43, 0x13, 0x30, 0xd6, 0xfa, 0x41, 0xd0, 0xb7,
	0xf0, 0xbf, 0xdd, 0x58, 0xfb, 0xb0, 0x1f, 0xed, 0x82, 0x89, 0x38, 0x6b, 0x18, 0xd9, 0x57, 0x77,
	0x3f, 0x7e, 0x6b, 0xcd, 0x27, 0xda, 0x03, 0x99, 0x6e, 0x50, 0x0a, 0x5f, 0x3d, 0x75, 0xf3, 0x52,
	0xdd, 0x87, 0xb7, 0x33, 0x33, 0xdd, 0x0b, 0x7f, 0xed, 0xfd, 0x4b, 0x67, 0xef, 0x04, 0xd0, 0x6d,
	0xed, 0x39, 0x45, 0x3a, 0x0f, 0xfe, 0xf7, 0xd5, 0xbb, 0x6b, 0x7d, 0x68, 0x12, 0xb6, 0x44, 0x58,
	0x03, 0x14, 0xff, 0xed, 0x27, 0xa7, 0xeb, 0x09, 0x94, 0x65, 0x45, 0x8c, 0x9c, 0xe2, 0xfc, 0x1f,
	0xe7, 0xbe, 0xf8, 0xa0, 0xe1, 0xf5, 0x7f, 0x30, 0xd9, 0xee, 0x95, 0x39, 0xdf, 0xf8, 0x77, 0xde,
	0x7c, 0xf9, 0xe2, 0x5a, 0xa7, 0x74, 0x58, 0xe8, 0x77, 0xa7, 0x5e, 0xfa, 0xa9, 0xde, 0x85, 0x98,
	0x39, 0xae, 0xf8, 0xbb, 0x97, 0xaf, 0xfd, 0xda, 0x98, 0x9f, 0xd8, 0x59, 0x0f, 0xcb, 0x3f, 0xbf,
	0x7a, 0xe3, 0xed, 0x33, 0x7d, 0x68, 0x37, 0x6c, 0x6d, 0x07, 0xb5, 0xd4, 0x49, 0xfe, 0xfa, 0x37,
	0x17, 0x7f, 0x69, 0x44, 0xba, 0x13, 0xd2, 0xed, 0xd8, 0xd6, 0xbd, 0xcf, 0xbf, 0xfe, 0xf3, 0xb5,
	0xeb, 0x09, 0xb1, 0xef, 0xb5, 0xb3, 0xe9, 0x9e, 0xc2, 0xad, 0x41, 0x18, 0x90, 0x17, 0x67, 0xfc,
	0xee, 0xee, 0x19, 0xd8, 0x14, 0x7f, 0x93, 0x9b, 0x0c, 0x0b, 0x43, 0xfc, 0xe2, 0x14, 0x47, 0xd8,
	0x0b, 0xb8, 0xd4, 0x83, 0x0e, 0xc3, 0x44, 0xd7, 0xbb, 0xd0, 0xce, 0x0e, 0x94, 0x11, 0x5c, 0x0c,
	0xf3, 0xde, 0xc6, 0x5f, 0x27, 0xcd, 0x9b, 0x85, 0x10, 0xe5, 0x0a, 0x2c, 0x31, 0x5f, 0xcb, 0xb0,
	0xb9, 0xc3, 0x7d, 0x21, 0xd3, 0x89, 0x25, 0x40, 0x88, 0xb1, 0x85, 0x45, 0xea, 0x41, 0x2a, 0x88,
	0x5d, 0x6e, 0x05, 0xff, 0xf9, 0x2b, 0x5e, 0xca, 0x9d, 0x0a, 0xae, 0xd9, 0x31, 0x05, 0x2e, 0x12,
	0x36, 0x7b, 0x0d, 0x88, 0x0b, 0x9b, 0x41, 0x88, 0xb1, 0x37, 0x78, 0xa9, 0x07, 0xbd, 0x00, 0xa9,
	0x6e, 0xbd, 0xfe, 0x8e, 0xf8, 0x19, 0x8a, 0xc0, 0xc4, 0x4d, 0xa1, 0xc4, 0xf3, 0xd8, 0x75, 0xd5,
	0x12, 0xa6, 0xc3, 0x52, 0x0f, 0xda, 0x0f, 0xa3, 0xed, 0xad, 0x7a, 0x2a, 0x26, 0xda, 0xc0, 0x28,
	0xb6, 0x57, 0x5e, 0x9a, 0xf9, 0xa6, 0xf8, 0x8e, 0x7c, 0xb2, 0x0b, 0x15, 0xcd, 0x7b, 0x33, 0x2b,
	0x69, 0x0b, 0xe7, 0x11, 0x18, 0xef, 0xdc, 0x77, 0x6f, 0x8f, 0xcf, 0x9b, 0x01, 0x89, 0xcd, 0xbf,
	0x13, 0x98, 0x71, 0xa9, 0x07, 0x15, 0x5b, 0x66, 0x8a, 0x25, 0x8e, 0x9b, 0xa9, 0x7b, 0x65, 0x3d,
	0xc0, 0x46, 0xcc, 0x76, 0xbf, 0x1d, 0x22, 0x66, 0x40, 0xf1, 0xe2, 0xce, 0xb3, 0x3b, 0xbe, 0xd9,
	0x76, 0x76, 0xd8, 0xf1, 0x21, 0x20, 0x9e, 0xee, 0x79, 0xd8, 0xd2, 0xa9, 0x93, 0xdb, 0x16, 0x4f,
	0xd8, 0x02, 0x89, 0xa7, 0x5c, 0x02, 0xa1, 0x63, 0x13, 0x23, 0xc5, 0x73, 0xb6, 0x62, 0x62, 0x49,
	0xa7, 0xe7, 0x6f, 0x5c, 0x49, 0x73, 0x5f, 0x5f, 0x4d, 0x73, 0x17, 0xae, 0xa6, 0xb9, 0xd5, 0xab,
	0x69, 0xee, 0xc8, 0xe3, 0x2d, 0x7f, 0xbb, 0x12, 0xac, 0x56, 0x4a, 0x8e, 0xda, 0x7c, 0xd8, 0xe3,
	0x62, 0xe7, 0x38, 0x76, 0xf2, 0xaa, 0x6d, 0xe7, 0xbd, 0x47, 0x43, 0xc3, 0x79, 0xea, 0xd0, 0xff,
	0x5d, 0xee, 0xa7, 0x0e, 0xa6, 0xfe, 0x0c, 0x00, 0x00, 0xff, 0xff, 0x18, 0xdf, 0xb9, 0xac, 0xd3,
	0x15, 0x00, 0x00,
}

func (this *PhotoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&media.PhotoSizeList{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "SizeId: "+fmt.Sprintf("%#v", this.SizeId)+",\n")
	if this.Sizes != nil {
		s = append(s, "Sizes: "+fmt.Sprintf("%#v", this.Sizes)+",\n")
	}
	s = append(s, "DcId: "+fmt.Sprintf("%#v", this.DcId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLPhotoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&media.TLPhotoSizeList{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VideoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&media.VideoSizeList{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "SizeId: "+fmt.Sprintf("%#v", this.SizeId)+",\n")
	if this.Sizes != nil {
		s = append(s, "Sizes: "+fmt.Sprintf("%#v", this.Sizes)+",\n")
	}
	s = append(s, "DcId: "+fmt.Sprintf("%#v", this.DcId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLVideoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&media.TLVideoSizeList{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadPhotoFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&media.TLMediaUploadPhotoFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.Stickers != nil {
		s = append(s, "Stickers: "+fmt.Sprintf("%#v", this.Stickers)+",\n")
	}
	if this.TtlSeconds != nil {
		s = append(s, "TtlSeconds: "+fmt.Sprintf("%#v", this.TtlSeconds)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadProfilePhotoFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&media.TLMediaUploadProfilePhotoFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.Video != nil {
		s = append(s, "Video: "+fmt.Sprintf("%#v", this.Video)+",\n")
	}
	if this.VideoStartTs != nil {
		s = append(s, "VideoStartTs: "+fmt.Sprintf("%#v", this.VideoStartTs)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetPhoto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetPhoto{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "PhotoId: "+fmt.Sprintf("%#v", this.PhotoId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetPhotoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetPhotoSizeList{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "SizeId: "+fmt.Sprintf("%#v", this.SizeId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetPhotoSizeListList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetPhotoSizeListList{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "IdList: "+fmt.Sprintf("%#v", this.IdList)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetVideoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetVideoSizeList{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "SizeId: "+fmt.Sprintf("%#v", this.SizeId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadedDocumentMedia) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&media.TLMediaUploadedDocumentMedia{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.Media != nil {
		s = append(s, "Media: "+fmt.Sprintf("%#v", this.Media)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetDocument) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetDocument{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetDocumentList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetDocumentList{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "IdList: "+fmt.Sprintf("%#v", this.IdList)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadEncryptedFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&media.TLMediaUploadEncryptedFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetEncryptedFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&media.TLMediaGetEncryptedFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "AccessHash: "+fmt.Sprintf("%#v", this.AccessHash)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadWallPaperFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&media.TLMediaUploadWallPaperFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	s = append(s, "MimeType: "+fmt.Sprintf("%#v", this.MimeType)+",\n")
	if this.Admin != nil {
		s = append(s, "Admin: "+fmt.Sprintf("%#v", this.Admin)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadThemeFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&media.TLMediaUploadThemeFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.Thumb != nil {
		s = append(s, "Thumb: "+fmt.Sprintf("%#v", this.Thumb)+",\n")
	}
	s = append(s, "MimeType: "+fmt.Sprintf("%#v", this.MimeType)+",\n")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadStickerFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&media.TLMediaUploadStickerFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.Thumb != nil {
		s = append(s, "Thumb: "+fmt.Sprintf("%#v", this.Thumb)+",\n")
	}
	s = append(s, "MimeType: "+fmt.Sprintf("%#v", this.MimeType)+",\n")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	if this.DocumentAttributeSticker != nil {
		s = append(s, "DocumentAttributeSticker: "+fmt.Sprintf("%#v", this.DocumentAttributeSticker)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadRingtoneFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&media.TLMediaUploadRingtoneFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	s = append(s, "MimeType: "+fmt.Sprintf("%#v", this.MimeType)+",\n")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Vector_PhotoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&media.Vector_PhotoSizeList{")
	if this.Datas != nil {
		s = append(s, "Datas: "+fmt.Sprintf("%#v", this.Datas)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Vector_Document) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&media.Vector_Document{")
	if this.Datas != nil {
		s = append(s, "Datas: "+fmt.Sprintf("%#v", this.Datas)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMediaTl(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCMediaClient is the client API for RPCMedia service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCMediaClient interface {
	MediaUploadPhotoFile(ctx context.Context, in *TLMediaUploadPhotoFile, opts ...grpc.CallOption) (*mtproto.Photo, error)
	MediaUploadProfilePhotoFile(ctx context.Context, in *TLMediaUploadProfilePhotoFile, opts ...grpc.CallOption) (*mtproto.Photo, error)
	MediaGetPhoto(ctx context.Context, in *TLMediaGetPhoto, opts ...grpc.CallOption) (*mtproto.Photo, error)
	MediaGetPhotoSizeList(ctx context.Context, in *TLMediaGetPhotoSizeList, opts ...grpc.CallOption) (*PhotoSizeList, error)
	MediaGetPhotoSizeListList(ctx context.Context, in *TLMediaGetPhotoSizeListList, opts ...grpc.CallOption) (*Vector_PhotoSizeList, error)
	MediaGetVideoSizeList(ctx context.Context, in *TLMediaGetVideoSizeList, opts ...grpc.CallOption) (*VideoSizeList, error)
	MediaUploadedDocumentMedia(ctx context.Context, in *TLMediaUploadedDocumentMedia, opts ...grpc.CallOption) (*mtproto.MessageMedia, error)
	MediaGetDocument(ctx context.Context, in *TLMediaGetDocument, opts ...grpc.CallOption) (*mtproto.Document, error)
	MediaGetDocumentList(ctx context.Context, in *TLMediaGetDocumentList, opts ...grpc.CallOption) (*Vector_Document, error)
	MediaUploadEncryptedFile(ctx context.Context, in *TLMediaUploadEncryptedFile, opts ...grpc.CallOption) (*mtproto.EncryptedFile, error)
	MediaGetEncryptedFile(ctx context.Context, in *TLMediaGetEncryptedFile, opts ...grpc.CallOption) (*mtproto.EncryptedFile, error)
	MediaUploadWallPaperFile(ctx context.Context, in *TLMediaUploadWallPaperFile, opts ...grpc.CallOption) (*mtproto.Document, error)
	MediaUploadThemeFile(ctx context.Context, in *TLMediaUploadThemeFile, opts ...grpc.CallOption) (*mtproto.Document, error)
	MediaUploadStickerFile(ctx context.Context, in *TLMediaUploadStickerFile, opts ...grpc.CallOption) (*mtproto.Document, error)
	MediaUploadRingtoneFile(ctx context.Context, in *TLMediaUploadRingtoneFile, opts ...grpc.CallOption) (*mtproto.Document, error)
}

type rPCMediaClient struct {
	cc *grpc.ClientConn
}

func NewRPCMediaClient(cc *grpc.ClientConn) RPCMediaClient {
	return &rPCMediaClient{cc}
}

func (c *rPCMediaClient) MediaUploadPhotoFile(ctx context.Context, in *TLMediaUploadPhotoFile, opts ...grpc.CallOption) (*mtproto.Photo, error) {
	out := new(mtproto.Photo)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadPhotoFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadProfilePhotoFile(ctx context.Context, in *TLMediaUploadProfilePhotoFile, opts ...grpc.CallOption) (*mtproto.Photo, error) {
	out := new(mtproto.Photo)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadProfilePhotoFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetPhoto(ctx context.Context, in *TLMediaGetPhoto, opts ...grpc.CallOption) (*mtproto.Photo, error) {
	out := new(mtproto.Photo)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getPhoto", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetPhotoSizeList(ctx context.Context, in *TLMediaGetPhotoSizeList, opts ...grpc.CallOption) (*PhotoSizeList, error) {
	out := new(PhotoSizeList)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getPhotoSizeList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetPhotoSizeListList(ctx context.Context, in *TLMediaGetPhotoSizeListList, opts ...grpc.CallOption) (*Vector_PhotoSizeList, error) {
	out := new(Vector_PhotoSizeList)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getPhotoSizeListList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetVideoSizeList(ctx context.Context, in *TLMediaGetVideoSizeList, opts ...grpc.CallOption) (*VideoSizeList, error) {
	out := new(VideoSizeList)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getVideoSizeList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadedDocumentMedia(ctx context.Context, in *TLMediaUploadedDocumentMedia, opts ...grpc.CallOption) (*mtproto.MessageMedia, error) {
	out := new(mtproto.MessageMedia)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadedDocumentMedia", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetDocument(ctx context.Context, in *TLMediaGetDocument, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetDocumentList(ctx context.Context, in *TLMediaGetDocumentList, opts ...grpc.CallOption) (*Vector_Document, error) {
	out := new(Vector_Document)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getDocumentList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadEncryptedFile(ctx context.Context, in *TLMediaUploadEncryptedFile, opts ...grpc.CallOption) (*mtproto.EncryptedFile, error) {
	out := new(mtproto.EncryptedFile)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadEncryptedFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetEncryptedFile(ctx context.Context, in *TLMediaGetEncryptedFile, opts ...grpc.CallOption) (*mtproto.EncryptedFile, error) {
	out := new(mtproto.EncryptedFile)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getEncryptedFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadWallPaperFile(ctx context.Context, in *TLMediaUploadWallPaperFile, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadWallPaperFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadThemeFile(ctx context.Context, in *TLMediaUploadThemeFile, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadThemeFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadStickerFile(ctx context.Context, in *TLMediaUploadStickerFile, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadStickerFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadRingtoneFile(ctx context.Context, in *TLMediaUploadRingtoneFile, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadRingtoneFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCMediaServer is the server API for RPCMedia service.
type RPCMediaServer interface {
	MediaUploadPhotoFile(context.Context, *TLMediaUploadPhotoFile) (*mtproto.Photo, error)
	MediaUploadProfilePhotoFile(context.Context, *TLMediaUploadProfilePhotoFile) (*mtproto.Photo, error)
	MediaGetPhoto(context.Context, *TLMediaGetPhoto) (*mtproto.Photo, error)
	MediaGetPhotoSizeList(context.Context, *TLMediaGetPhotoSizeList) (*PhotoSizeList, error)
	MediaGetPhotoSizeListList(context.Context, *TLMediaGetPhotoSizeListList) (*Vector_PhotoSizeList, error)
	MediaGetVideoSizeList(context.Context, *TLMediaGetVideoSizeList) (*VideoSizeList, error)
	MediaUploadedDocumentMedia(context.Context, *TLMediaUploadedDocumentMedia) (*mtproto.MessageMedia, error)
	MediaGetDocument(context.Context, *TLMediaGetDocument) (*mtproto.Document, error)
	MediaGetDocumentList(context.Context, *TLMediaGetDocumentList) (*Vector_Document, error)
	MediaUploadEncryptedFile(context.Context, *TLMediaUploadEncryptedFile) (*mtproto.EncryptedFile, error)
	MediaGetEncryptedFile(context.Context, *TLMediaGetEncryptedFile) (*mtproto.EncryptedFile, error)
	MediaUploadWallPaperFile(context.Context, *TLMediaUploadWallPaperFile) (*mtproto.Document, error)
	MediaUploadThemeFile(context.Context, *TLMediaUploadThemeFile) (*mtproto.Document, error)
	MediaUploadStickerFile(context.Context, *TLMediaUploadStickerFile) (*mtproto.Document, error)
	MediaUploadRingtoneFile(context.Context, *TLMediaUploadRingtoneFile) (*mtproto.Document, error)
}

// UnimplementedRPCMediaServer can be embedded to have forward compatible implementations.
type UnimplementedRPCMediaServer struct {
}

func (*UnimplementedRPCMediaServer) MediaUploadPhotoFile(ctx context.Context, req *TLMediaUploadPhotoFile) (*mtproto.Photo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadPhotoFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadProfilePhotoFile(ctx context.Context, req *TLMediaUploadProfilePhotoFile) (*mtproto.Photo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadProfilePhotoFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetPhoto(ctx context.Context, req *TLMediaGetPhoto) (*mtproto.Photo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetPhoto not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetPhotoSizeList(ctx context.Context, req *TLMediaGetPhotoSizeList) (*PhotoSizeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetPhotoSizeList not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetPhotoSizeListList(ctx context.Context, req *TLMediaGetPhotoSizeListList) (*Vector_PhotoSizeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetPhotoSizeListList not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetVideoSizeList(ctx context.Context, req *TLMediaGetVideoSizeList) (*VideoSizeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetVideoSizeList not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadedDocumentMedia(ctx context.Context, req *TLMediaUploadedDocumentMedia) (*mtproto.MessageMedia, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadedDocumentMedia not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetDocument(ctx context.Context, req *TLMediaGetDocument) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetDocument not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetDocumentList(ctx context.Context, req *TLMediaGetDocumentList) (*Vector_Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetDocumentList not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadEncryptedFile(ctx context.Context, req *TLMediaUploadEncryptedFile) (*mtproto.EncryptedFile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadEncryptedFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetEncryptedFile(ctx context.Context, req *TLMediaGetEncryptedFile) (*mtproto.EncryptedFile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetEncryptedFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadWallPaperFile(ctx context.Context, req *TLMediaUploadWallPaperFile) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadWallPaperFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadThemeFile(ctx context.Context, req *TLMediaUploadThemeFile) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadThemeFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadStickerFile(ctx context.Context, req *TLMediaUploadStickerFile) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadStickerFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadRingtoneFile(ctx context.Context, req *TLMediaUploadRingtoneFile) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadRingtoneFile not implemented")
}

func RegisterRPCMediaServer(s *grpc.Server, srv RPCMediaServer) {
	s.RegisterService(&_RPCMedia_serviceDesc, srv)
}

func _RPCMedia_MediaUploadPhotoFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadPhotoFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadPhotoFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadPhotoFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadPhotoFile(ctx, req.(*TLMediaUploadPhotoFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadProfilePhotoFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadProfilePhotoFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadProfilePhotoFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadProfilePhotoFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadProfilePhotoFile(ctx, req.(*TLMediaUploadProfilePhotoFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetPhoto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetPhoto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetPhoto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetPhoto",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetPhoto(ctx, req.(*TLMediaGetPhoto))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetPhotoSizeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetPhotoSizeList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetPhotoSizeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetPhotoSizeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetPhotoSizeList(ctx, req.(*TLMediaGetPhotoSizeList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetPhotoSizeListList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetPhotoSizeListList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetPhotoSizeListList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetPhotoSizeListList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetPhotoSizeListList(ctx, req.(*TLMediaGetPhotoSizeListList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetVideoSizeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetVideoSizeList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetVideoSizeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetVideoSizeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetVideoSizeList(ctx, req.(*TLMediaGetVideoSizeList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadedDocumentMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadedDocumentMedia)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadedDocumentMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadedDocumentMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadedDocumentMedia(ctx, req.(*TLMediaUploadedDocumentMedia))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetDocument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetDocument(ctx, req.(*TLMediaGetDocument))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetDocumentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetDocumentList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetDocumentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetDocumentList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetDocumentList(ctx, req.(*TLMediaGetDocumentList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadEncryptedFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadEncryptedFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadEncryptedFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadEncryptedFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadEncryptedFile(ctx, req.(*TLMediaUploadEncryptedFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetEncryptedFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetEncryptedFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetEncryptedFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetEncryptedFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetEncryptedFile(ctx, req.(*TLMediaGetEncryptedFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadWallPaperFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadWallPaperFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadWallPaperFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadWallPaperFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadWallPaperFile(ctx, req.(*TLMediaUploadWallPaperFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadThemeFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadThemeFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadThemeFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadThemeFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadThemeFile(ctx, req.(*TLMediaUploadThemeFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadStickerFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadStickerFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadStickerFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadStickerFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadStickerFile(ctx, req.(*TLMediaUploadStickerFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadRingtoneFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadRingtoneFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadRingtoneFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadRingtoneFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadRingtoneFile(ctx, req.(*TLMediaUploadRingtoneFile))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCMedia_serviceDesc = grpc.ServiceDesc{
	ServiceName: "media.RPCMedia",
	HandlerType: (*RPCMediaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "media_uploadPhotoFile",
			Handler:    _RPCMedia_MediaUploadPhotoFile_Handler,
		},
		{
			MethodName: "media_uploadProfilePhotoFile",
			Handler:    _RPCMedia_MediaUploadProfilePhotoFile_Handler,
		},
		{
			MethodName: "media_getPhoto",
			Handler:    _RPCMedia_MediaGetPhoto_Handler,
		},
		{
			MethodName: "media_getPhotoSizeList",
			Handler:    _RPCMedia_MediaGetPhotoSizeList_Handler,
		},
		{
			MethodName: "media_getPhotoSizeListList",
			Handler:    _RPCMedia_MediaGetPhotoSizeListList_Handler,
		},
		{
			MethodName: "media_getVideoSizeList",
			Handler:    _RPCMedia_MediaGetVideoSizeList_Handler,
		},
		{
			MethodName: "media_uploadedDocumentMedia",
			Handler:    _RPCMedia_MediaUploadedDocumentMedia_Handler,
		},
		{
			MethodName: "media_getDocument",
			Handler:    _RPCMedia_MediaGetDocument_Handler,
		},
		{
			MethodName: "media_getDocumentList",
			Handler:    _RPCMedia_MediaGetDocumentList_Handler,
		},
		{
			MethodName: "media_uploadEncryptedFile",
			Handler:    _RPCMedia_MediaUploadEncryptedFile_Handler,
		},
		{
			MethodName: "media_getEncryptedFile",
			Handler:    _RPCMedia_MediaGetEncryptedFile_Handler,
		},
		{
			MethodName: "media_uploadWallPaperFile",
			Handler:    _RPCMedia_MediaUploadWallPaperFile_Handler,
		},
		{
			MethodName: "media_uploadThemeFile",
			Handler:    _RPCMedia_MediaUploadThemeFile_Handler,
		},
		{
			MethodName: "media_uploadStickerFile",
			Handler:    _RPCMedia_MediaUploadStickerFile_Handler,
		},
		{
			MethodName: "media_uploadRingtoneFile",
			Handler:    _RPCMedia_MediaUploadRingtoneFile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "media.tl.proto",
}

func (m *PhotoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhotoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhotoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DcId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.DcId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Sizes) > 0 {
		for iNdEx := len(m.Sizes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sizes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SizeId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.SizeId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLPhotoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLPhotoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLPhotoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VideoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DcId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.DcId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Sizes) > 0 {
		for iNdEx := len(m.Sizes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sizes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SizeId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.SizeId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLVideoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLVideoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLVideoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadPhotoFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadPhotoFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadPhotoFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TtlSeconds != nil {
		{
			size, err := m.TtlSeconds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Stickers) > 0 {
		for iNdEx := len(m.Stickers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stickers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadProfilePhotoFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadProfilePhotoFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadProfilePhotoFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VideoStartTs != nil {
		{
			size, err := m.VideoStartTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetPhoto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetPhoto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PhotoId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.PhotoId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetPhotoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetPhotoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetPhotoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SizeId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.SizeId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetPhotoSizeListList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetPhotoSizeListList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetPhotoSizeListList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IdList) > 0 {
		dAtA9 := make([]byte, len(m.IdList)*10)
		var j8 int
		for _, num1 := range m.IdList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintMediaTl(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetVideoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetVideoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetVideoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SizeId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.SizeId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadedDocumentMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadedDocumentMedia) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadedDocumentMedia) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetDocumentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetDocumentList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetDocumentList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IdList) > 0 {
		dAtA12 := make([]byte, len(m.IdList)*10)
		var j11 int
		for _, num1 := range m.IdList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintMediaTl(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadEncryptedFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadEncryptedFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadEncryptedFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetEncryptedFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetEncryptedFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetEncryptedFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AccessHash != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x20
	}
	if m.Id != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadWallPaperFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadWallPaperFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadWallPaperFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Admin != nil {
		{
			size, err := m.Admin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadThemeFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadThemeFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadThemeFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x32
	}
	if m.Thumb != nil {
		{
			size, err := m.Thumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadStickerFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadStickerFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadStickerFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DocumentAttributeSticker != nil {
		{
			size, err := m.DocumentAttributeSticker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x32
	}
	if m.Thumb != nil {
		{
			size, err := m.Thumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadRingtoneFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadRingtoneFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadRingtoneFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vector_PhotoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector_PhotoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector_PhotoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datas) > 0 {
		for iNdEx := len(m.Datas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Datas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Vector_Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector_Document) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector_Document) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datas) > 0 {
		for iNdEx := len(m.Datas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Datas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintMediaTl(dAtA []byte, offset int, v uint64) int {
	offset -= sovMediaTl(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PhotoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.SizeId != 0 {
		n += 1 + sovMediaTl(uint64(m.SizeId))
	}
	if len(m.Sizes) > 0 {
		for _, e := range m.Sizes {
			l = e.Size()
			n += 1 + l + sovMediaTl(uint64(l))
		}
	}
	if m.DcId != 0 {
		n += 1 + sovMediaTl(uint64(m.DcId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLPhotoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.SizeId != 0 {
		n += 1 + sovMediaTl(uint64(m.SizeId))
	}
	if len(m.Sizes) > 0 {
		for _, e := range m.Sizes {
			l = e.Size()
			n += 1 + l + sovMediaTl(uint64(l))
		}
	}
	if m.DcId != 0 {
		n += 1 + sovMediaTl(uint64(m.DcId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLVideoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadPhotoFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if len(m.Stickers) > 0 {
		for _, e := range m.Stickers {
			l = e.Size()
			n += 1 + l + sovMediaTl(uint64(l))
		}
	}
	if m.TtlSeconds != nil {
		l = m.TtlSeconds.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadProfilePhotoFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.VideoStartTs != nil {
		l = m.VideoStartTs.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.PhotoId != 0 {
		n += 1 + sovMediaTl(uint64(m.PhotoId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetPhotoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.SizeId != 0 {
		n += 1 + sovMediaTl(uint64(m.SizeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetPhotoSizeListList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if len(m.IdList) > 0 {
		l = 0
		for _, e := range m.IdList {
			l += sovMediaTl(uint64(e))
		}
		n += 1 + sovMediaTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetVideoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.SizeId != 0 {
		n += 1 + sovMediaTl(uint64(m.SizeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadedDocumentMedia) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.Id != 0 {
		n += 1 + sovMediaTl(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetDocumentList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if len(m.IdList) > 0 {
		l = 0
		for _, e := range m.IdList {
			l += sovMediaTl(uint64(e))
		}
		n += 1 + sovMediaTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadEncryptedFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetEncryptedFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.Id != 0 {
		n += 1 + sovMediaTl(uint64(m.Id))
	}
	if m.AccessHash != 0 {
		n += 1 + sovMediaTl(uint64(m.AccessHash))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadWallPaperFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Admin != nil {
		l = m.Admin.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadThemeFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadStickerFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.DocumentAttributeSticker != nil {
		l = m.DocumentAttributeSticker.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadRingtoneFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vector_PhotoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Datas) > 0 {
		for _, e := range m.Datas {
			l = e.Size()
			n += 1 + l + sovMediaTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vector_Document) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Datas) > 0 {
		for _, e := range m.Datas {
			l = e.Size()
			n += 1 + l + sovMediaTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMediaTl(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMediaTl(x uint64) (n int) {
	return sovMediaTl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PhotoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhotoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhotoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeId", wireType)
			}
			m.SizeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sizes = append(m.Sizes, &mtproto.PhotoSize{})
			if err := m.Sizes[len(m.Sizes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLPhotoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_photoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_photoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &PhotoSizeList{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeId", wireType)
			}
			m.SizeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sizes = append(m.Sizes, &mtproto.VideoSize{})
			if err := m.Sizes[len(m.Sizes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLVideoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_videoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_videoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &VideoSizeList{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadPhotoFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadPhotoFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadPhotoFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stickers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stickers = append(m.Stickers, &mtproto.InputDocument{})
			if err := m.Stickers[len(m.Stickers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlSeconds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TtlSeconds == nil {
				m.TtlSeconds = &types.Int32Value{}
			}
			if err := m.TtlSeconds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadProfilePhotoFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadProfilePhotoFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadProfilePhotoFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &mtproto.InputFile{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoStartTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VideoStartTs == nil {
				m.VideoStartTs = &types.DoubleValue{}
			}
			if err := m.VideoStartTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoId", wireType)
			}
			m.PhotoId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetPhotoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getPhotoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getPhotoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeId", wireType)
			}
			m.SizeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetPhotoSizeListList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getPhotoSizeListList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getPhotoSizeListList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMediaTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IdList = append(m.IdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMediaTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMediaTl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMediaTl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IdList) == 0 {
					m.IdList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMediaTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IdList = append(m.IdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IdList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetVideoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getVideoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getVideoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeId", wireType)
			}
			m.SizeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadedDocumentMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadedDocumentMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadedDocumentMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &mtproto.InputMedia{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetDocumentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getDocumentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getDocumentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMediaTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IdList = append(m.IdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMediaTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMediaTl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMediaTl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IdList) == 0 {
					m.IdList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMediaTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IdList = append(m.IdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IdList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadEncryptedFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadEncryptedFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadEncryptedFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputEncryptedFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetEncryptedFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getEncryptedFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getEncryptedFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadWallPaperFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadWallPaperFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadWallPaperFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Admin == nil {
				m.Admin = &mtproto.Bool{}
			}
			if err := m.Admin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadThemeFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadThemeFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadThemeFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &mtproto.InputFile{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadStickerFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadStickerFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadStickerFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &mtproto.InputFile{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentAttributeSticker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DocumentAttributeSticker == nil {
				m.DocumentAttributeSticker = &mtproto.DocumentAttribute{}
			}
			if err := m.DocumentAttributeSticker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadRingtoneFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadRingtoneFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadRingtoneFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector_PhotoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector_PhotoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector_PhotoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datas = append(m.Datas, &PhotoSizeList{})
			if err := m.Datas[len(m.Datas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector_Document) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector_Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector_Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datas = append(m.Datas, &mtproto.Document{})
			if err := m.Datas[len(m.Datas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMediaTl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMediaTl
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMediaTl
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMediaTl
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMediaTl        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMediaTl          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMediaTl = fmt.Errorf("proto: unexpected end of group")
)
